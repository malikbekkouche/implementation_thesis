/**
 * Implementation of dictionary ADT with a non-blocking chromatic search tree.
 * Copyright (C) 2013 Trevor Brown
 * Contact (tabrown [at] cs [dot] toronto [dot] edu) with questions or comments.
 *
 * Details of the chromatic search tree algorithm appear in the paper:
 *    "A general technique for non-blocking trees"
 * by Trevor Brown (Univeristy of Toronto)
 *    Faith Ellen  (University of Toronto)
 *    Eric Ruppert (York University)
 * 
 * This optimized version performs rebalancing only once a path from the root
 * to a leaf contains at least d violations of the red-black tree invariants,
 * where d is a constant specified when an instance of the tree is created.
 * Increasing d decreases the number of rotations that must be performed
 * at the cost of increasing search time. Since searches are extremely fast,
 * this trade off is often very beneficial for moderate values of d.
 * When d = 0, each put() or remove() fixes any violation it created before
 * returning to the caller.
 *
 * This data structure has:
 *  -- entirely non-blocking (also called lock-free) operations
 *  -- height that is O(c+d+log n), where n is the number of keys in the
 *     dictionary, d is the constant mentioned above, and c is the number of
 *     insertions and deletions currently in progress.
 *     (the constants hidden by the big-O notation are small.)
 * 
 * If there is interest in using this data structure, but it lacks some basic
 * functionality that is required, Trevor Brown is open to expanding this work.
 * For instance, it is possible to add:
 *  -- the ability to atomically { remove any number of nodes/keys/values
 *     (even if they are scattered throughout the tree), and add one },
 *  -- linearizable size(), clone(), iterators, range queries, and
 *  -- the ability to compose operations by layering transactional memory
 *     on top of the fast non-blocking operations offered by this tree.
 * 
 * As an interesting side note, less than 550 lines of code in this file were
 * written by hand.  The remainder were generated by a computer program,
 * which can be adapted to produce code for other balanced trees.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import java.util.AbstractMap.SimpleEntry;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

//added
import javax.xml.ws.Holder;
import java.util.Collection;
import java.util.AbstractMap.SimpleEntry;
import java.util.ArrayList;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.Arrays;




public class ConcurrentChromaticTreeMap<K,V> {
	private final int d; // this is the number of violations to allow on a search path before we fix everything on it. if d is zero, then each update fixes any violation it created before returning.
	private static final int DEFAULT_d = 6; // experimentally determined to yield good performance for both random workloads, and operations on sorted sequences
	//private final Node root;
	public final Node root;
	private final Operation dummy;
	private final Comparator<? super K> comparator;
	private final AtomicReferenceFieldUpdater<ConcurrentChromaticTreeMap.Node, ConcurrentChromaticTreeMap.Operation> updateOp;
	private final AtomicReferenceFieldUpdater<ConcurrentChromaticTreeMap.Node, ConcurrentChromaticTreeMap.Node> updateLeft, updateRight;
	private final AtomicReferenceFieldUpdater<ConcurrentChromaticTreeMap.Node, ConcurrentChromaticTreeMap.Node> updatePrev;

	// added for gcas
	private final char LEFT='L';
	private final char RIGHT='R';
	private volatile boolean isSnapshot;
	private volatile int generation;
	private volatile int maxSnapId =-1;
	public boolean isReadOnly=false;
	public ArrauList<Node> snapList;

	public ConcurrentChromaticTreeMap() {
		this(DEFAULT_d, null); 
	}
	public ConcurrentChromaticTreeMap(final Comparator<? super K> cmp) {
		this(DEFAULT_d, cmp);
	}
	public ConcurrentChromaticTreeMap(final int allowedViolationsPerPath) {
		this(allowedViolationsPerPath, null);
	}
	public ConcurrentChromaticTreeMap(final int allowedViolationsPerPath, final Comparator<? super K> cmp) {
		d = allowedViolationsPerPath;
		comparator = cmp;
		dummy = new Operation();
		Gen gen=new Gen();
		root = new Node(null, null, 1, new Node(null, null, 1, null, null, dummy), null, dummy,gen.gen);
		updateOp = AtomicReferenceFieldUpdater.newUpdater(Node.class, Operation.class, "op");
		updateLeft = AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, "left");
		updateRight = AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, "right");
		updatePrev = AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, "prev");
		snapList=new ArrayList();
	}

	public ConcurrentChromaticTreeMap(Node root, boolean isReadOnly) {
		/* if(default(TValue) != null) {
				throw new Exception("Type of TValue must be a nullable type.");
			} */
		d = 6;
		dummy = new Operation();
		this.root = root;
		this.isReadOnly = isReadOnly;
		comparator=null;
		updateOp = AtomicReferenceFieldUpdater.newUpdater(Node.class, Operation.class, "op");
		updateLeft = AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, "left");
		updateRight = AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, "right");
		updatePrev = AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, "prev");
	}

	/**
	 * size() is NOT a constant time method, and the result is only guaranteed to
	 * be consistent if no concurrent updates occur.
	 * Note: linearizable size() and iterators can be implemented, so contact
	 *       the author if they are needed for some application.
	 */
	public final int size() {
		return sequentialSize(root);
	}
	private int sequentialSize(final Node node) {
		if (node == null) return 0;
		if (node.left == null && node.key != null) return 1;
		return sequentialSize(node.left) + sequentialSize(node.right);
	}

	public boolean checkOrderTree(){
		return checkOrderOfTree(root.left.left);
	}

	public int transformTreeToMap(Map<K,V> map){
		return transformTreeToMap_(root.left.left,map);
	}

	public int transformTreeToMap_(final Node node, Map<K,V> map){
		if(node == null) return 0;
		if(node != null && node.left == null && node.right == null){
			map.put((K)node.key, (V)node.value);			
		}
		return transformTreeToMap_(node.left, map) + transformTreeToMap_(node.right, map);			
	}

	public boolean checkOrderOfTree(final Node node){		
		if(node == null) return true;
		else{
			//Comparable<K> k = (Comparable<K>) comparable(node.key);
			final Comparable<? super K> k = comparable(node.key);
			if(node.left!=null && node.right!=null){				
				if(k.compareTo((K) node.left.key) < 0 || k.compareTo((K) node.right.key) > 0){
					return false;
				}
			}else if(node.left!=null){
				if(k.compareTo((K) node.left.key) < 0)
					return false;
			}else if(node.right!=null){
				if(k.compareTo((K) node.right.key) > 0)
					return false;
			}
		}		
		return checkOrderOfTree(node.left) && checkOrderOfTree(node.right);
	}

	public final int transformToList(List<K> list){
		return  transformTreeToList(root, list);
	}
	public int transformTreeToList(final Node node, List<K> list){
		if (node == null) return 0;
		if (node.left == null && node.key != null){
			list.add((K) node.key);        	
			return 1;        
		}
		return transformTreeToList(node.left, list) + transformTreeToList(node.right, list);
	}

	public final boolean containsKey(final K key) {
		return get(key) != null;
	}

	public final V get(final K key) {
		final Comparable<? super K> k = comparable(key);
		/* Node l = root.left.left;
		if (l == null) return null; // no keys in data structure
		while (l.left != null) {
			l = (k.compareTo((K) l.key) < 0) ? l.left : l.right;
		} */

		SearchRecord searchRecord=search(key,true);
		System.out.println("######### ");
		for(Node n: searchRecord.nodeList){
			System.out.print(n.key + " ");
		}
		
		System.out.println("********* " );
		for(Object n: searchRecord.directionList){
			System.out.print((char)n + " ");
		}
		
		

		if(searchRecord.n.lastGen == this.root.gen){
			if(k.compareTo((K) searchRecord.n.key) == 0)
				return (V)searchRecord.n.value;
			else
				return null;
		}
		if(searchRecord.n.gen > this.root.gen)
			return null;
		return (searchRecord.grandParent != null && k.compareTo((K) searchRecord.n.key) == 0) ? (V) searchRecord.n.value : null;
	}

	// only adds if element not in the tree
	// return true if element added, false otherwise

	public final boolean add(final K key,final V value){ 
		return doPut(key,value,true) != null ? false : true;
	}


	private final Node getNode(final K key) {
		final Comparable<? super K> k = comparable(key);
		Node l = root.left.left;
		if (l == null) return null; // no keys in data structure
		while (l.left != null) {
			l = (k.compareTo((K) l.key) < 0) ? l.left : l.right;
		}
		return (k.compareTo((K) l.key) == 0) ?  l : null;
	}

	// returns true if the element was updated
	// returns false if the key was not in the tree
	// copy-pasted the do put method and changed some parts
	// mostly commented out a few lines
	public final boolean update(final K key,final V value){
		final Comparable<? super K> k = comparable(key);
		boolean found = false;
		Operation op = null;
		Node p = null, l = null;
		int count = 0;

		while (true) {
			while (op == null) {
				p = root;
				l = root.left;
				if (l.left != null) {
					count = 0;
					p = l;
					l = l.left; // note: before executing this line, l must have key infinity, and l.left must not.
					while (l.left != null) {
						if (d > 0 && (l.weight > 1 || l.weight == 0 && p.weight == 0)) ++count;
						p = l;
						l = (k.compareTo((K) l.key) < 0) ? l.left : l.right;
						//l = (k.compareTo((K) l.key) < 0) ? l.right : l.left;//**MUTATION
					}
				}

				// if we find the key in the tree already
				if (l.key != null && k.compareTo((K) l.key) == 0) {
					found = true;
					//if (onlyIfAbsent) return (V) l.value;
					op = createReplaceOp(p, l, key, value);
				} else {
					found = false;
					return found;
					//op = createInsertOp(p, l, key, value, k);
				}
			}
			if (helpSCX(op, 0)) {
				// clean up violations if necessary
				if (d == 0) {
					if (!found && p.weight == 0 && l.weight == 1) fixToKey(k);
				} else {
					if (count >= d) fixToKey(k);
				}
				// we may have found the key and replaced its value (and, if so, the old value is stored in the old node)
				//return (found ? (V) l.value : null);
				return found;
			}
			op = null;
		}
	}

	// the same as the previous one but returns the value in the Holder
	public final boolean update(final K key,final V value, Holder<V> oldValue){
		final Comparable<? super K> k = comparable(key);
		boolean found = false;
		Operation op = null;
		Node p = null, l = null;
		int count = 0;

		while (true) {
			while (op == null) {
				p = root;
				l = root.left;
				if (l.left != null) {
					count = 0;
					p = l;
					l = l.left; // note: before executing this line, l must have key infinity, and l.left must not.
					while (l.left != null) {
						if (d > 0 && (l.weight > 1 || l.weight == 0 && p.weight == 0)) ++count;
						p = l;
						l = (k.compareTo((K) l.key) < 0) ? l.left : l.right;
						//l = (k.compareTo((K) l.key) < 0) ? l.right : l.left;//**MUTATION
					}
				}

				// if we find the key in the tree already
				if (l.key != null && k.compareTo((K) l.key) == 0) {
					found = true;
					//if (onlyIfAbsent) return (V) l.value;
					oldValue.value=(V)l.value;
					//System.out.println("old "+oldValue.value);
					op = createReplaceOp(p, l, key, value);
				} else {
					found = false;
					return found;
					//op = createInsertOp(p, l, key, value, k);
				}
			}
			if (helpSCX(op, 0)) {
				// clean up violations if necessary
				if (d == 0) {
					if (!found && p.weight == 0 && l.weight == 1) fixToKey(k);
				} else {
					if (count >= d) fixToKey(k);
				}
				// we may have found the key and replaced its value (and, if so, the old value is stored in the old node)
				//return (found ? (V) l.value : null);
				return found;
			}
			op = null;
		}
	}

	// return true if the key was in the tree 
	// replace the keys value with value
	// return false otherwise and adds k,v
	public final boolean updateOrAdd(final K key,final V value){
		return doPut(key,value,false) == null ? false : true;
	}

	// same as previous method but returns the old value
	public final boolean updateOrAdd(final K key,final V value, Holder<V> oldValue){
		oldValue.value=doPut(key,value,false);
		return oldValue == null ? false : true;
	}

	// C5 --
	// return true if k is present, false otherwise
	// returns the value in holder
	public final boolean find(final K key, Holder<V> oldValue){
		oldValue.value=get(key);
		return oldValue == null ? false : true;
	}

	//C5
	// returns true if the dictionary contains an entry whose key
	// equals k and if so removes that entry; otherwise returns false.
	public boolean remove(final K k){
		V result = newRemove(k, 0);
		if(result != null)
			return true;
		return false;
	}

	//C5
	//set the default value of out (???)
	// eturns true if the dictionary contains an entry
	// whose key equals k and if so removes that entry and assigns the associated
	// value to v; otherwise returns false and assigns the default value for T to v.
	public boolean remove(final K k, Holder<V> out){
		V result  = remove(k, 0);
		if(result!=null){
			out.value = result;
			return true;
		}else{
			out.value = (V)null;
			return false;
		}
	}

	//C5
	// returns true if the dictionary contains an en-
	// try whose key equals k and if so assigns the associated value to v; otherwise
	// returns false and adds a new entry with key k and associated value v to the
	// dictionary
	public boolean findOrAdd(final K k, final V v){
		V result = put(k, v);
		if(result != null)
			return true;
		else
			return false;
	}

	//C5
	// returns true if the dictionary contains an entry whose
	// key equals k; otherwise false.
	public boolean contains(final K k){
		if(get(k) != null)
			return true;
		return false;
	}

	public final void addAll(Collection<SimpleEntry<K,V>> col){
		Iterator<SimpleEntry<K,V>> itr=col.iterator();
		while(itr.hasNext()){
			SimpleEntry<K,V> entry =itr.next();
			add(entry.getKey(),entry.getValue());
		}

	}


	// returns pred if key is largest
	public final Node successor(K key,CyclicBarrier b){
		final Comparable<? super K> comp = comparable(key);
		boolean bool=false;
		while(true){
			//System.out.println("start");
			ArrayList<Node> nodes=new ArrayList();
			ArrayList<Operation> ops=new ArrayList();
			Node lastLeft=root.left.left;
			Node n=root.left.left;
			while(!n.isLeaf()){  
				if(comp.compareTo((K)n.key)<0){//key<n.key
					lastLeft=n;
					n=n.left;
					nodes=new ArrayList();
					nodes.add(lastLeft);
					ops=new ArrayList();
					ops.add(lastLeft.op);
				}else{
					n=n.right;
					nodes.add(n);
					ops.add(n.op);
				}
			}
			if( comp.compareTo((K)n.key)<0 ){//key<n.key
				return n;
			}else{
				Node succ=lastLeft.right;
				while(!succ.isLeaf()){
					nodes.add(succ);
					ops.add(succ.op);
					succ=succ.left;
				}
				if(bool==false){
					try{
						//System.out.println("wait");
						b.await();}catch(Exception e){////System.out.println("tree");
						}
				}
				if(vlx(nodes,ops))
					if(comp.compareTo((K)succ.key)<0){
						//System.out.println("vlx succeeded");
						return succ;
					}

					else
						return null;
				else{
					//System.out.println("vlx failed");
					bool=true;
					//continue;
				}

			}

		}

	}

	public final Node successor(K key){
		final Comparable<? super K> comp = comparable(key);
		while(true){
			ArrayList<Node> nodes=new ArrayList();
			ArrayList<Operation> ops=new ArrayList();
			Node lastLeft=root.left.left;
			Node n=root.left.left;
			while(!n.isLeaf()){  
				if(comp.compareTo((K)n.key)<0){//key<n.key
					lastLeft=n;
					n=n.left;
					nodes=new ArrayList();
					nodes.add(lastLeft);
					ops=new ArrayList();
					ops.add(lastLeft.op);
				}else{
					n=n.right;
					nodes.add(n);
					ops.add(n.op);
				}
			}
			if( comp.compareTo((K)n.key)<0 ){//key<n.key
				return n;
			}else{
				Node succ=lastLeft.right;
				while(!succ.isLeaf()){
					nodes.add(succ);
					ops.add(succ.op);
					succ=succ.left;
				}
				if(vlx(nodes,ops))
					if(comp.compareTo((K)succ.key)<0)
						return succ;
					else
						return null;
				else
					continue;
			}
		}
	}

	public final Node predecessor(K key){
		final Comparable<? super K> comp = comparable(key);
		while(true){
			ArrayList<Node> nodes=new ArrayList();
			ArrayList<Operation> ops=new ArrayList();
			Node lastRight=root.left.left;
			Node n=root.left.left;
			while(!n.isLeaf()){  
				if(comp.compareTo((K)n.key)>0){//key<n.key
					lastRight=n;
					n=n.right;
					nodes=new ArrayList();
					nodes.add(lastRight);
					ops=new ArrayList();
					ops.add(lastRight.op);
				}else{
					n=n.left;
					nodes.add(n);
					ops.add(n.op);
				}
			}
			if( comp.compareTo((K)n.key)>0 ){//key<n.key
				return n;
			}else{
				Node succ=lastRight.left;
				while(!succ.isLeaf()){
					nodes.add(succ);
					ops.add(succ.op);
					succ=succ.left;
				}
				if(vlx(nodes,ops))
					if(comp.compareTo((K)succ.key)>0)
						return succ;
					else
						return null;
				else
					continue;
			}
		}

	}

	private boolean vlx(ArrayList<Node> nodes,ArrayList<Operation> ops){
		for (int i=0; i<ops.size(); ++i) {
			if(!ops.get(i).equals(nodes.get(i).op))
				return false;
		}
		return true;
	}

	// should be more generic and return collection
	public final ArrayList rangeFrom(K key){
		ArrayList<SimpleEntry<K,V>> list=new ArrayList();
		Node from=getNode(key);
		if (from == null){
			from=successor(key);
		}
		list.add(new SimpleEntry<K,V>((K)from.key,(V)from.value));
		while((from=successor((K)from.key))!=null){
			list.add(new SimpleEntry<K,V>((K)from.key,(V)from.value));
		}

		return list;
	}

	public final ArrayList rangeFromTo(K k1,K k2){
		final Comparable<? super K> comp = comparable(k2);
		ArrayList<SimpleEntry<K,V>> list=new ArrayList();
		Node from=getNode(k1);
		if (from == null){
			from=successor(k1);
		}
		list.add(new SimpleEntry<K,V>((K)from.key,(V)from.value));
		while((from=successor((K)from.key))!=null && comp.compareTo((K)from.key)>0){
			list.add(new SimpleEntry<K,V>((K)from.key,(V)from.value));
		}

		return list;
	}

	public final ArrayList rangeTo(K key){
		final Comparable<? super K> comp = comparable(key);
		ArrayList<SimpleEntry<K,V>> list=new ArrayList();
		SimpleEntry<K,V> min=findMin();
		Node from=getNode((K)min.getKey());

		list.add(new SimpleEntry<K,V>((K)from.key,(V)from.value));
		while((from=successor((K)from.key))!=null && comp.compareTo((K)from.key)>0){
			list.add(new SimpleEntry<K,V>((K)from.key,(V)from.value));
		}

		return list;
	}



	// this is to test

	//C5
	// returns the entry with minimal key from the
	// sorted dictionary, if any
	public SimpleEntry<K,V> findMin(){
		Node temp = root.left.left;
		if(temp == null)
			return null;
		while(temp.left!=null){
			temp = temp.left;
		}
		SimpleEntry<K,V> pair = new SimpleEntry<K,V>((K)temp.key, (V)temp.value);
		return pair;
	}

	//C5
	// removes and returns the entry with minimal key from the sorted dictionary, if any
	public SimpleEntry<K,V> deleteMin(){
		SimpleEntry<K,V> temp = findMin();
		if(temp != null){
			if(remove(temp.getKey(), 0) != null)
				return temp;
		}
		return null;		
	}

	//C5
	// returns the entry with maximal key from the sorted dictionary, if any.
	public SimpleEntry<K,V> findMax(){
		Node temp = root.left.left;
		if(temp == null)
			return null;
		while(temp.right!=null){
			temp = temp.right;
		}
		SimpleEntry<K,V> pair = new SimpleEntry<K,V>((K)temp.key, (V)temp.value);
		return pair;
	}

	//C5
	// removes and returns the entry with maximal key from the sorted dictionary, if any.
	public SimpleEntry<K,V> deleteMax(){
		SimpleEntry<K,V> temp = findMax();
		if(temp != null){
			if(remove(temp.getKey(), 0) != null)
				return temp;
		}
		return null;	
	}


	//C5
	// returns true if there is a successor of k and in that case binds the successor to res; otherwise returns
	// false and binds the default value of KeyValuePair<K,V> to res.
	// set default value to out ???
	public boolean trySuccessor(K key, Holder<SimpleEntry<K,V>> out){
		Node temp = successor(key);
		if(temp != null){
			SimpleEntry<K,V> entry = new SimpleEntry<K,V>((K)temp.key, (V)temp.value);
			out.value = entry;
			return true;
		}
		out = null;
		return false;
	}


	//C5
	public final Node weakSuccessor(K key){
		final Comparable<? super K> comp = comparable(key);
		while(true){
			ArrayList<Node> nodes=new ArrayList();
			ArrayList<Operation> ops=new ArrayList();
			Node lastLeft=root.left.left;
			Node n=root.left.left;
			while(!n.isLeaf()){  
				if(comp.compareTo((K)n.key) <= 0){//key<n.key
					lastLeft=n;
					n=n.left;
					nodes=new ArrayList();
					nodes.add(lastLeft);
					ops=new ArrayList();
					ops.add(lastLeft.op);
				}else{
					n=n.right;
					nodes.add(n);
					ops.add(n.op);
				}
			}
			if( comp.compareTo((K)n.key) <= 0 ){//key<n.key
				return n;
			}else{
				Node succ=lastLeft.right;
				while(!succ.isLeaf()){
					nodes.add(succ);
					ops.add(succ.op);
					succ=succ.left;
				}
				if(vlx(nodes,ops))
					if(comp.compareTo((K)succ.key) <= 0)
						return succ;
					else
						return null;
				else
					continue;

			}

		}

	}



	//C5
	// returns true if there is a weak successor of k and in that case binds the weak successor to res;
	// otherwise returns false and binds the default value of KeyValuePair<K,V> to res.
	// set default value to out ???
	public boolean tryWeakSuccessor(K key, Holder<SimpleEntry<K,V>> out){
		Node temp = weakSuccessor(key);
		if(temp != null){
			SimpleEntry<K,V> entry = new SimpleEntry<K,V>((K)temp.key, (V)temp.value);
			out.value = entry;
			return true;
		}
		out.value = null;
		return false;
	}



	//C5
	public final Node weakPredecessor(K key){
		final Comparable<? super K> comp = comparable(key);
		while(true){
			ArrayList<Node> nodes=new ArrayList();
			ArrayList<Operation> ops=new ArrayList();
			Node lastRight=root.left.left;
			Node n=root.left.left;
			while(!n.isLeaf()){  
				if(comp.compareTo((K)n.key) >= 0){//key<n.key
					lastRight=n;
					n=n.right;
					nodes=new ArrayList();
					nodes.add(lastRight);
					ops=new ArrayList();
					ops.add(lastRight.op);
				}else{
					n=n.left;
					nodes.add(n);
					ops.add(n.op);
				}
			}
			if( comp.compareTo((K)n.key) >= 0 ){//key<n.key
				return n;
			}else{
				Node succ=lastRight.left;
				while(!succ.isLeaf()){
					nodes.add(succ);
					ops.add(succ.op);
					succ=succ.left;
				}
				if(vlx(nodes,ops))
					if(comp.compareTo((K)succ.key) >= 0)
						return succ;
					else
						return null;
				else
					continue;

			}
		}
	}

	//C5
	// returns true if there is a precedessor of k and in that case binds the predecessor to res; otherwise
	// returns false and binds the default value of KeyValuePair<K,V> to res
	// set default value to out ???
	public boolean tryPredecessor(K key, Holder<SimpleEntry<K,V>> out){
		Node temp = predecessor(key);
		if(temp != null){
			SimpleEntry<K,V> entry = new SimpleEntry<K,V>((K)temp.key, (V)temp.value);
			out.value = entry;
			return true;
		}
		out.value = null;
		return false;
	}

	//C5
	// eturns true if there is a weak precedessor of k and in that case binds the weak prede-
	// cessor to res; otherwise returns false and binds the default value of Key-
	// ValuePair<K,V> to res
	// set default value to out ???
	public boolean tryWeakPredecessor(K key, Holder<SimpleEntry<K,V>> out){
		Node temp = weakPredecessor(key);
		if(temp != null){
			SimpleEntry<K,V> entry = new SimpleEntry<K,V>((K)temp.key, (V)temp.value);
			out.value = entry;
			return true;
		}
		out.value = null;
		return false;
	}

	private boolean GCAS(Node in, Node old, Node n,char dir){
		n.prev=old;
		boolean casResult;
		casResult = (dir == LEFT) ? updateLeft.compareAndSet(in,old,n) : updateRight.compareAndSet(in,old,n);
		if(casResult){
			GCAS_COMMIT(in,n,dir);
			return n.prev==null;
		}else
			return false;

	}

	private Node GCAS_COMMIT(Node in, Node m, char dir){
		Node p=m.prev;
		Node r=root;// should be abbortable_read
		boolean casResult;
		if(p==null)
			return m;
		if(p.failed){
			casResult = (dir == LEFT) ? updateLeft.compareAndSet(in,m,p.prev) : updateRight.compareAndSet(in,m,p.prev);
			if(casResult)
				return p.prev;
			else
				return dir == LEFT ? GCAS_COMMIT(in,in.left,dir) : GCAS_COMMIT(in,in.right,dir);
		}else{
			if(r.gen==in.gen){//skipped read-only for now
				if(updatePrev.compareAndSet(m,p,null))
					return m;
				else
					return GCAS_COMMIT(in,m,dir);
			}else{
				updatePrev.compareAndSet(m,p,new Node(p,true));
				return dir == LEFT ? GCAS_COMMIT(in,in.left,dir) : GCAS_COMMIT(in,in.right,dir);
			}	
		}
	}

	private Node GCAS_READ(Node in,char dir){
		Node m = dir == LEFT ? in.left : in.right ;
		if(m.prev==null)
			return m;
		else
			return GCAS_COMMIT(in,m,dir);
	}

	public SearchRecord search(K key,boolean readOp){ // readOnly maybe
		ArrayList<Node> nodeList = new ArrayList<Node>();//used to store list of nodes from root to the target node
		ArrayList directionList = new ArrayList();
		boolean updateSnapshot = false;
		while(true){
			//System.out.println("while");
			final Comparable<? super K> comp = comparable(key);
			Node ggp=null,gp=null,p=null,n=null;
			boolean retry;
			Node root=RDCSS_ABORTABLE_READ();
			int gen=root.gen;
			char dir=LEFT;
			Node sentinel=GCAS_READ(root,dir);
			//System.out.println("while");
			if(sentinel.gen==gen || readOp){
				if(sentinel.left==null)
					return new SearchRecord(null,null,root,sentinel,gen);
				//System.out.println("in");
				gp=root;
				p=sentinel;
				int violations=0;
				//nodeList.add(sentinel);
				while(true){
					//System.out.println("inner");
					n=GCAS_READ(p,dir);
					
					
					while(true){//while(!n.isLeaf()){
						//System.out.println("SEARCH METHOD " + n.key + " - " + n.gen);
						nodeList.add(n);//add to list of nodes
						directionList.add(dir);						
						if((!this.isReadOnly && n.isLeaf()) || (this.isReadOnly && n.isLeaf() && n.extra == null))
							break;												
						if(n.gen==gen || this.isReadOnly){//if the tree is live tree -- n.gen==gen
							//on the snapshot we don't care about violation
							if(!this.isReadOnly){
								if(n.weight>1 || (n.left.weight==0 && p.weight==0)) // was originally only l
									violations++;
							}
							ggp=gp;
							gp=p;
							p=n;
							//System.out.println("search node "+key+": "+n.key+"*"+n.gen);
							dir= (comp.compareTo((K)n.key)<0) ? LEFT : RIGHT;
							//System.out.println("searching n "+dir+n.key +" "+n.gen);
							//System.out.println("node key = " + n.key + " - dir = " + dir);
							//used if there is an extra pointer of a node
							//System.out.println("node "+n.key+" "+dir);
							if(this.isReadOnly == true && n.extra!=null ){//only go to extra pointer if the current tree is a snapshot
								//System.out.println("extra");
								if(dir == LEFT && n.extraDir == LEFT || 
										(dir == RIGHT && n.extraDir == RIGHT)){
									//System.out.println("direction :"+dir+n.key);
									n = n.extra;		
									//System.out.println("direction :"+dir+ " " + n.key);

								}else{//we should go left when we have extra right and vice versa
									if(n.isLeaf())
										break;
									
									n = (dir == LEFT ) ? n.left : n.right;
									//System.out.println("dir n "+dir);
								}
							}else if(this.isReadOnly){//lack of case Snapshot get the element
								n = (dir == LEFT) ? n.left : n.right;			
								//System.out.println("direction :"+dir+ " " +n.key);
							}
							else{
								n=GCAS_READ(n,dir);
								//System.out.println("direction :"+dir+ " " +n.key);
							}
						}else{
							break;
						}
						
					}
					//System.out.println("leaf "+key+": "+n.key+"*"+n.gen+"*"+n.lastGen+"*"+n.value);
					if(n.gen==gen || (readOp && this.isReadOnly)){//live tree read here	
						//System.out.println("print :"+n.key+" "+n.gen+gen);					
						return new SearchRecord(ggp,gp,p,n,gen,violations, nodeList, directionList, updateSnapshot);
					}else{
						//System.out.println("generation" +n.key+" "+n.gen+" "+p.gen);
						
						if(!GCAS_COPY(p,n,dir,gen)){
							retry=true;//continue;//return RETRY; or continue maybe??
							//System.out.println("retry");
						}else {
							updateSnapshot = true;
						}
						//System.out.println("generation" +n.key+" "+n.gen+" "+p.gen);
					}

				}
			}
			else{
				//System.out.println("generation else"+" : root"+root.gen+root.marked+" sentinel " +sentinel.gen+sentinel.marked+ " left "+sentinel.left.key+" "+sentinel.left.gen+" "+sentinel.left.marked);
				GCAS_COPY(root,sentinel,dir,gen);
				retry=true;//continue;//return retry;

			}

		}
	}


	private boolean newHelpSCXX(Operation op){
		final AtomicIntegerFieldUpdater<Operation> updateStep = 
				AtomicIntegerFieldUpdater.newUpdater(Operation.class, "step");//need to be checked also		
		Node[] nodes=op.nodes;
		Operation[] ops=op.ops;
		Node subtree=op.subtree;
		int gen=op.gen;
		AtomicReferenceFieldUpdater genericUpdater;
		for(int i=0;i<ops.length;i++){
			if(!updateOp.compareAndSet(nodes[i],ops[i],op) && nodes[i].op != op){ // check order of cas
				if(!op.allFrozen){
					op.state=Operation.STATE_ABORTED;
					return false;
				}
			}
		}
		op.allFrozen=true;
		boolean left;
		if(nodes[0].left==nodes[1]){
			genericUpdater=updateLeft;
			left=true;
		}else{
			genericUpdater=updateRight;
			left=false;
		}

		while(true){
			if(op.state!=Operation.STATE_INPROGRESS){
				return op.state==Operation.STATE_COMMITTED ? true : false ;
			}
			int step=op.step;
			if(step==Operation.STEP_SUBTREE){
				if(genericUpdater.compareAndSet(nodes[0],nodes[1],subtree) ||
						(left ? (nodes[0].left==nodes[1]) : (nodes[0].right==nodes[1]) )){
					updateStep.compareAndSet(op,step,Operation.STEP_GENERATION);
					////System.out.println("op "+op.step );
				}else{
					updateStep.compareAndSet(op,step,Operation.STEP_ABORT);
				}
			}else if(step==Operation.STEP_GENERATION){
				Node root=RDCSS_ABORTABLE_READ();
				if(root.gen==nodes[1].gen){
					updateStep.compareAndSet(op,step,Operation.STEP_COMMIT);
					////System.out.println("commit");
				}else{
					/* updateStep.compareAndSet(op,step,Operation.STEP_ABORT);
					//System.out.println("ab"); */
					AtomicIntegerFieldUpdater<Node> up=AtomicIntegerFieldUpdater.newUpdater(Node.class, "gen");
					Node sentinel=nodes[1];
					/* if(up.compareAndSet(sentinel,nodes[1].gen,root.gen))
						System.out.println("updated gen "+nodes[1].key+" "+nodes[1].gen);
					else  */
					if(!up.compareAndSet(sentinel,nodes[1].gen,root.gen))
						updateStep.compareAndSet(op,step,Operation.STEP_ABORT);
				}
			}else if(step==Operation.STEP_ABORT){
				if(genericUpdater.compareAndSet(nodes[0],subtree,nodes[1])){
					op.state=Operation.STATE_ABORTED;
					////System.out.println("aborted");
					return false;
				}
			}else if(step==Operation.STEP_COMMIT){
				/* for(int i=1;i<nodes.length;i++){
					nodes[i].marked=true;
				} */
				op.state=Operation.STATE_COMMITTED;
				//System.out.println("final gen for node "+nodes[1].gen+" "+nodes[1].key);
				//System.out.println("commited");
				return true;
			}
		}
	}

	private boolean helpSCXX(Operation op){
		final AtomicIntegerFieldUpdater<Operation> updateStep = 
				AtomicIntegerFieldUpdater.newUpdater(Operation.class, "step");//need to be checked also		
		Node[] nodes=op.nodes;
		Operation[] ops=op.ops;
		Node subtree=op.subtree;
		int gen=op.gen;
		AtomicReferenceFieldUpdater genericUpdater;
		System.out.println("before");
		for(int i=0;i<ops.length;i++){
			if(!updateOp.compareAndSet(nodes[i],ops[i],op) && nodes[i].op != op){ // check order of cas
				if(!op.allFrozen){
					op.state=Operation.STATE_ABORTED;
					return false;
				}
			}
		}
		System.out.println("after");
		op.allFrozen=true;
		boolean left;
		if(nodes[0].left==nodes[1]){
			genericUpdater=updateLeft;
			left=true;
		}else{
			genericUpdater=updateRight;
			left=false;
		}

		while(true){
			System.out.println("some");
			if(op.state!=Operation.STATE_INPROGRESS){
				return op.state==Operation.STATE_COMMITTED ? true : false ;
			}
			int step=op.step;
			System.out.println("where");
			if(step==Operation.STEP_SUBTREE){
				//System.out.println("syb");
				//if(left)
				//System.out.println("left : "+nodes[0].left.key+"-"+nodes[0].left.value+nodes[0].left.extra+"*"+nodes[1].key+"-"+nodes[1].value+nodes[1].extra);
				//else
				//System.out.println("right "+ nodes[0].right.key+"-"+nodes[0].right.value+nodes[0].right.extra+"*"+nodes[1].key+"-"+nodes[1].value+nodes[1].extra);
				if(genericUpdater.compareAndSet(nodes[0],nodes[1],subtree) ||
						(left ? (nodes[0].left==nodes[1]) : (nodes[0].right==nodes[1]) )){
					updateStep.compareAndSet(op,step,Operation.STEP_GENERATION);
					System.out.println("SUBTREE " );
				}else{
					updateStep.compareAndSet(op,step,Operation.STEP_ABORT);
					System.out.println("b");
				}
			}else if(step==Operation.STEP_GENERATION){
				Node root=RDCSS_ABORTABLE_READ();
				if(root.gen==nodes[0].gen){
					updateStep.compareAndSet(op,step,Operation.STEP_COMMIT);
					System.out.println("GENERATION");
				}else{
					updateStep.compareAndSet(op,step,Operation.STEP_ABORT);
					System.out.println("ab");
					System.out.println("gen "+root.gen+nodes[0].gen);
				}
			}else if(step==Operation.STEP_ABORT){
				System.out.println("u");
				if(genericUpdater.compareAndSet(nodes[0],subtree,nodes[1])){
					op.state=Operation.STATE_ABORTED;
					System.out.println("aborted");
					return false;
				}
			}else if(step==Operation.STEP_COMMIT){
				for(int i=1;i<nodes.length;i++){
					nodes[i].marked=true;
				}
				op.state=Operation.STATE_COMMITTED;
				System.out.println("commited");
				return true;
			}
		}
	}

	private Node RDCSS_ABORTABLE_READ(){
		return RDCSS_READ(true);//need to be checked
	}

	private Node RDCSS_READ(boolean abort){
		Node r = root;
		if(r.op instanceof Descriptor){
			return (Node)RDCSS_COMPLETE(abort);
		}
		else 
			return r;		
	}

	private boolean RDCSS(Node ov, Operation sent, Node nv){
		Descriptor desc = new Descriptor(ov, sent, nv);
		if(CAS_ROOT(root.op, desc)){
			RDCSS_COMPLETE(false);
			return desc.committed;
		}else
			return false;
	}

	private Node RDCSS_COMPLETE(boolean abort){
		Node v = root;
		Operation op=v.op;

		if(op instanceof Descriptor) {//v is instanceof Descriptor
			Descriptor desc = (Descriptor)op;
			if(abort){
				if(CAS_ROOT(desc, new Operation(1))){
					return desc.oldValue;
				}else{
					return RDCSS_COMPLETE(abort);
				}
			}else{
				//Node oldMain = GCAS_READ(desc.oldValue,LEFT);//should be specified direction dir
				if(weakLLX(GCAS_READ(desc.oldValue, LEFT)) == desc.sentinelOp){
					//AtomicReference ar=new AtomicReference(v
					final AtomicIntegerFieldUpdater<Node> updateGen = 
							AtomicIntegerFieldUpdater.newUpdater(Node.class, "gen");//need to be checked also	
					if(updateGen.compareAndSet(v,desc.oldValue.gen, desc.newValue.gen)){
						desc.committed = true;
						//System.out.println("root "+root.gen+" - "+"old "+desc.oldValue.gen+" - n "+desc.newValue.gen);
						return desc.newValue;
					}
					else{
						//System.out.println("error");
						return RDCSS_COMPLETE(abort);
					}

				}else{
					//System.out.println("error 2");
					if(CAS_ROOT(desc, new Operation(1)))
						return desc.oldValue;
					else
						return RDCSS_COMPLETE(abort);
				}
			}
		}else {
			return v;
		}
	}

	private boolean CAS_ROOT(Operation ov, Operation nv){
		//AtomicReference<Node> ref=new AtomicReference(root);
		return updateOp.compareAndSet(root,ov, nv);//should be double check ???		
	}

	private boolean GCAS_COPY(Node p,Node n,char dir,int gen){ // returns true if node updated with new gen

		/* Operation op=createReplaceOp(p,n,n.gen);		
		//check direction of parent node

		if(dir == LEFT)
		{
			return (p.left == n);
		}else if(dir == RIGHT){
			return (p.right == n);
		}
		return helpSCXX(op); // original took int also */	


		Operation[] ops = new Operation[] { null, null};
		Node[] nodes = new Node[] { null, null };

		if(!weakLLX(p, 0, ops, nodes)) {
			//System.out.println("false1");
			return false;
		}

		if(!weakLLX(n, 1, ops, nodes)) {
			//System.out.println("false2");
			//System.out.println(ops[1].state);
			return false;
		} 


		if(dir==LEFT){
			if(p.left!=n)
				return false;
		}else{
			if(p.right!=n)
				return false;
		}

		// Create copy of o, and create operation
		Node node = new Node(n, gen);
		Operation op = new Operation(nodes, ops, n);
		op.gen=gen;
		n.op = op;

		if(newHelpSCXX(op)) {
			// Copy operation was committed, and traversal can continue
			//System.out.println("true");
			return true;
		} else {
			// Copy operation failed, traversal will retry after reading the node again
			//System.out.println("false");
			return false;
		}

	}

	private ConcurrentChromaticTreeMap DoReadOnlySnapshot() {
		while(true) {
			//System.out.println("snap");
			Node root = RDCSS_READ(false);
			Operation rootOp = weakLLX(root);
			// rootOp is null if another operation was undergoing.
			if(rootOp != null) {
				//System.out.println("if");
				Node left = GCAS_READ(root, LEFT);
				Operation leftOp = weakLLX(left);
				if(RDCSS(root, leftOp /*was leftOp*/, new Node(null,null,1, left, null, /*true is sentinel ,*/ rootOp, new Gen().gen))) {
					//TODO: Return old root instead of this new one? New one will point to the same anyways
					//return new ConcurrentTreeDictionarySnapshot<TKey, TValue>(new Node(1, left, null, true, new Gen()), true);
					return new ConcurrentChromaticTreeMap(root, true);
				}
			}
		}
	}

	public ConcurrentChromaticTreeMap snapshot() {
		while(true) {
			//System.out.println("snap");
			Node root = RDCSS_READ(false);
			Operation rootOp = weakLLX(root);
			// rootOp is null if another operation was undergoing.
			if(rootOp != null) {
				//System.out.println("if");
				Node left = GCAS_READ(root, LEFT);
				Operation leftOp = weakLLX(left);
				Node r=new Node(null,null,1, left, null, /*true is sentinel ,*/ rootOp, root.gen+1);
				int oldGen = root.gen;
				if(RDCSS(root, leftOp /*was leftOp*/, r)) {
					//TODO: Return old root instead of this new one? New one will point to the same anyways
					//return new ConcurrentTreeDictionarySnapshot<TKey, TValue>(new Node(1, left, null, true, new Gen()), true);
					maxSnapId++;
					//System.out.println("return "+root.gen+" - "+r.gen);
					Node newRoot=new Node(null,null,1, left, null, dummy,oldGen);
					snapList.add(newRoot);
					return new ConcurrentChromaticTreeMap(newRoot, true);					
				}
			}
		}
	}
	
	public ConcurrentChromaticTreeMap createSnapshot() {
		while(true) {
			//System.out.println("snap");
			Node root = RDCSS_READ(false);
			Operation rootOp = weakLLX(root);
			// rootOp is null if another operation was undergoing.
			if(rootOp != null) {
				//System.out.println("if");
				Node left = GCAS_READ(root, LEFT);
				Operation leftOp = weakLLX(left);
				Node r=new Node(null,null,1, left, null, /*true is sentinel ,*/ rootOp, root.gen+1);
				int oldGen = root.gen;
				if(RDCSS(root, leftOp /*was leftOp*/, r)) {
					//TODO: Return old root instead of this new one? New one will point to the same anyways
					//return new ConcurrentTreeDictionarySnapshot<TKey, TValue>(new Node(1, left, null, true, new Gen()), true);
					maxSnapId++;
					//System.out.println("return "+root.gen+" - "+r.gen);
					return new ConcurrentChromaticTreeMap(new Node(null,null,1, left, null, dummy,oldGen), true);					
				}
			}
		}
	}



	private Operation createReplaceOp(final Node p, final Node l,final int gen) {// same as old version except
		final Operation[] ops = new Operation[]{null}; // it puts the same node with diff gen
		final Node[] nodes = new Node[]{null, l};
		int newGen=l.gen+1;

		if (!weakLLX(p, 0, ops, nodes)) return null;

		if (l != p.left && l != p.right) return null;

		// Build new sub-tree
		final Node subtree = new Node(l,newGen);
		subtree.parent = p;
		return new Operation(nodes, ops, subtree);
	}


	private Operation createReplaceOpSnap(final Node gp,final Node p, final Node l,K key, V value , final int gen) {// same as old version except
		/* final Operation[] ops = new Operation[]{null}; // it puts the same node with diff gen
		final Node[] nodes = new Node[]{null, l};
		int newGen=gen;//maybe wrong

		if (!weakLLX(p, 0, ops, nodes)) return null;

		if (l != p.left && l != p.right) return null; */
		int newGen=gen;//maybe wrong
		final Operation[] ops = new Operation[]{null, null, null};
		final Node[] nodes = new Node[]{null, null, null};

		if (!weakLLX(gp, 0, ops, nodes)) return null;
		if (!weakLLX(p, 1, ops, nodes)) return null;

		if (p != gp.left && p != gp.right) return null;
		final boolean left = (l == p.left);
		if (!left && l != p.right) return null;

		// Read fields for the sibling of l into ops[2], nodes[2] = s
		if (!weakLLX(left ? p.right : p.left, 2, ops, nodes)) return null;
		final Node s = nodes[2];


		char dir = (p.left==l) ? LEFT : RIGHT;
		Node newChild = new Node(l);
		newChild.lastGen=newGen-1;
		newChild.gen=newGen;

		// Build new sub-tree
		final Node updated=new Node(key,value,l.weight,l.left,l.right,l.op,l.gen);
		updated.lastGen=newGen;//new child has updated lastGen
		Node subtree;
		if(dir==LEFT)
			subtree = new Node(p.key,p.value,p.weight,updated,p.right,p.op,p.gen);//make sure to use the correct constructor
		else
			subtree = new Node(p.key,p.value,p.weight,p.left,updated,p.op,p.gen);//make sure to use the correct constructor
		subtree.parent = p.parent;

		//put extra
		subtree.extra=newChild;
		subtree.extraDir=dir;

		//System.out.println("subtree "+subtree.key+" "+subtree.left.key+subtree.left.value+" "+subtree.right.key+" "+subtree.extra.key+subtree.extra.value);
		//System.out.println("sub "+subtree.key+"-"+subtree.value+"-"+subtree.gen+"-"+subtree.lastGen+" / extra"+subtree.extra.key+"-"+subtree.extra.value+"-"+subtree.extra.gen+"-"+subtree.extra.lastGen);
		return new Operation(nodes, ops, subtree);
	}
	/*
	
	private Operation createReplaceOpReal(final Node gp,final Node p, final Node l,K key, V value , final int gen) {
		int newGen=gen;//maybe wrong
		final Operation[] ops = new Operation[]{null, null, null};
		final Node[] nodes = new Node[]{null, null, null};
		final Comparable<? super K> k = comparable(key);
	
		
		
		
		ArrayList<Node> nodeList=new ArrayList();
		ArrayList<Character> dirList=new ArrayList();
		ArrayList<Operation> opsArray=new ArrayList();
		ArrayList<Node> nodesArray=new ArrayList();
		System.out.println("1");
		
		// remember weakLLX
		Node n= root.left;
		nodeList.add(n);
		n=n.left;
		char dir;
		while(!n.isLeaf()){ // create list of nodes on the path + the directions taken
			dir = (k.compareTo((K)n.key)<0) ? LEFT : RIGHT ;
			dirList.add(dir);
			nodeList.add(n);
			if(dir==LEFT){
				System.out.println("dir "+dir+" * " +n.key+ " "+n.gen);
				n=n.left;
				
			}
			else{
				System.out.println("dir "+dir+" * " +n.key+ " "+n.gen);
				n=n.right;
			}
		}
		nodeList.add(n);
		dirList.add(0,LEFT);
		System.out.println("2");
		int i=nodeList.size()-1;
		int j=dirList.size()-1;
		for(Node v : nodeList)
			System.out.println("noden "+v.key+v.value);
		// node to put in extra
		Node oldNode=nodeList.get(i);
		// node to put in live tree
		Node holder=nodeList.get(i);
		Node updatedNode = new Node(holder.key,value,holder.weight,holder.left,holder.right,holder.op,holder.gen);
		System.out.println("nodee "+oldNode.key);
		
		//if (!weakLLX(nodeList.get(i), 0, opsArray, nodesArray)) return null;
		
		Node extraTree=null;
		
		//build live tree
		i--;
		// weak llx on sibling and parent
		if (!weakLLX(nodeList.get(i), 0, opsArray, nodesArray)) return null;
		System.out.println("llx "+nodeList.get(i).gen +" "+nodeList.get(i).key);
		Node node= dirList.get(j)==LEFT ? nodeList.get(i).right : nodeList.get(i).left;
		if (!weakLLX(node, 1, opsArray, nodesArray)) return null;
		System.out.println("llx "+node.gen +" "+node.key);
		// maybe also check the sibling
		Node parent;
		while(true){
			System.out.println("node kg"+nodeList.get(i).key+" "+nodeList.get(i).gen);
			parent=nodeList.get(i); // make copy so the live tree is not changed
			char direction=dirList.get(j);
			if(direction==RIGHT){
				parent.right=updatedNode;// make sure the constructor copies every atribute
			}else{
				parent.left=updatedNode;
			}
			i--;
			j--;
			//weak llx on grand parent
			if (!weakLLX(nodeList.get(i), 0, opsArray, nodesArray)) return null;
			System.out.println("llx "+nodeList.get(i).key +" "+nodeList.get(i).gen);
			if(parent.extra!=null)
				extraTree=createExtraSubtree(parent.extra,oldNode);
			else{
				System.out.println("break");
				break;}
			updatedNode=parent;
		}
		
		if(extraTree==null){
			System.out.println("null ");
			parent.extra=oldNode;
		}else{
			parent.extra=extraTree;
		}
		System.out.println("extra "+parent.extra.key+parent.extra.value);
		System.out.println("parent "+parent.key+" "+parent.gen+" "+parent.left.key+parent.left.value+parent.right.key);
		Node[] nodesArr = new Node[nodesArray.size()];
		nodesArr = nodesArray.toArray(new Node[0]);

		Operation[] opsArr = new Operation[opsArray.size()];
		opsArr = opsArray.toArray(new Operation[0]);
		
		for(int x=0;x<nodesArr.length;x++)
			System.out.println("nodex "+nodesArr[x].key+nodesArr[x].value);

		return new Operation(nodesArr, opsArr, parent);
		
	}
	
	private Node createExtraSubtree(Node extra, Node newExtra){
		final Comparable<? super K> k = comparable(newExtra.key);
		Node n=extra;// make a copy so we still have reference to the root
		char dir;
		while(!n.isLeaf()){
			dir = (k.compareTo((K)n.key)<0) ? LEFT : RIGHT ;
			n = (dir==LEFT) ? n.left : n.right ;
		}
		if(k.compareTo((K)n.key)<0){
			n.left=newExtra;
			n.right=n;
			return extra;
		}else {
			Node newRoot=newExtra;
			while(!newRoot.isLeaf())
				newRoot=newRoot.left;
			Node r=newRoot;
			r.left=extra;
			r.right=newExtra;
			return r;
		}
	}
	*/

	private Operation createReplaceOpSnapLoop(final Node gp,final Node p, final Node l,K key, V value , final int gen) {// same as old version except
		/* final Operation[] ops = new Operation[]{null}; // it puts the same node with diff gen
		final Node[] nodes = new Node[]{null, l};
		int newGen=gen;//maybe wrong

		if (!weakLLX(p, 0, ops, nodes)) return null;

		if (l != p.left && l != p.right) return null; */
		int newGen=gen;//maybe wrong
		final Operation[] ops = new Operation[]{null, null, null};
		final Node[] nodes = new Node[]{null, null, null};

		ArrayList<Operation> opsArray;
		ArrayList<Node> nodesArray;

		Node newP=null;
		Node subtree=null;
		Node parentExtra=null;
		//make non final copies
		Node ll=l,pp=p,gpp=gp;
		//System.out.println("1");


		if (!weakLLX(gp, 0, ops, nodes)) return null;
		if (!weakLLX(p, 1, ops, nodes)) return null;

		//System.out.println("2");


		if (p != gp.left && p != gp.right) return null;
		final boolean left = (l == p.left);
		if (!left && l != p.right) return null;

		// Read fields for the sibling of l into ops[2], nodes[2] = s
		if (!weakLLX(left ? p.right : p.left, 2, ops, nodes)) return null;
		final Node s = nodes[2];
		//System.out.println("3");
		int index=3;
		opsArray=new ArrayList<>(Arrays.asList(ops));
		nodesArray=new ArrayList<>(Arrays.asList(nodes));


		char dir = (p.left==l) ? LEFT : RIGHT;
		Node newChild = new Node(ll);
		newChild.lastGen=newGen-1;
		newChild.gen=newGen;

		if(pp.extra==null){
			// Build new sub-tree
			//System.out.println("p: "+p.key+p.value);
			final Node updated=new Node(key,value,ll.weight,ll.left,ll.right,ll.op,ll.gen);
			updated.lastGen=newGen;//new child has updated lastGen			
			if(dir==LEFT)
				subtree = new Node(pp.key,pp.value,pp.weight,updated,pp.right,pp.op,pp.gen);//make sure to use the correct constructor
			else
				subtree = new Node(pp.key,pp.value,pp.weight,pp.left,updated,pp.op,pp.gen);//make sure to use the correct constructor						
			subtree.parent = pp.parent;

			//put extra
			subtree.extra=newChild;
			subtree.extraDir=dir;
			System.out.println("if");
			//System.out.println(dir+" "+subtree.extra.key);
		}else{			
			while(pp.extra!=null){

				final Comparable<? super K> k = comparable(ll.key);

				//System.out.println("while");
				//if(pp.extra.left!=null && pp.extra.right!=null)
					//System.out.println("LR/updating to "+key+"*"+value+" / extra :"+pp.extra.left.key+pp.extra.right.key+" p: "+pp.key+pp.value);	
				//else
					//System.out.println("updating to "+key+"*"+value+" / extra :"+pp.extra.key+"-"+pp.extra.value+" p: "+pp.key+pp.value);
				if(ll.extra!=null){
					System.out.println("tifo");
					if(k.compareTo((K)pp.extra.key)<0){

						//parentExtra=new Node(subtree.extra.key,subtree.extra.value,subtree.weight,subtree.extra,pp.extra,subtree.extra.op);
						/* Node parentRight=new Node(pp.extra);
						Node parentLeft=new Node(pp.left);
						parentExtra.right=parentRight;
						parentExtra.left=parentLeft; */
						//create updated live tree
						Node newSubtree=pp.right;
						while(!newSubtree.isLeaf()){
							newSubtree=newSubtree.left;
						}
						//System.out.println("new "+newSubtree.key);
						parentExtra=new Node(newSubtree.key,newSubtree.value,newSubtree.weight,subtree.extra,pp.extra,subtree.extra.op);
						
						Node updated=new Node(pp.key,pp.value,pp.weight,pp.left,pp.right,pp.op,pp.gen);
						

						System.out.println("1updated "+updated.key+"/"+updated.left.key+updated.left.value+"/"+updated.right.key+updated.right.value);
						System.out.println("debug "+subtree.extra.key+"/"+subtree.extra.left.key+"/"+subtree.extra.right.key);
						System.out.println("debug2 "+parentExtra.key+"/"+parentExtra.left.key+"/"+parentExtra.right.key);

						//newP=new Node(gpp.key,gpp.value,gpp.weight,gpp.left,updated,gpp.op,gpp.gen);//original before fix
						
						
						
						Comparable<? super K> kk = comparable(gpp.key);

						if(kk.compareTo((K)pp.key) < 0 ){
							newP=new Node(gpp.key,gpp.value,gpp.weight,gpp.left,updated,gpp.op,gpp.gen);	
						}else{
							newP=new Node(gpp.key,gpp.value,gpp.weight,updated,gpp.right,gpp.op,gpp.gen);
						}											
						//System.out.println("NewP.key = " + newP.key + " newP.left = " + newP.left.key + " newP.right = " + newP.right.key);

						if (!weakLLX(gpp, 0, opsArray, nodesArray)) return null;
						//System.out.println("ifo");
					}else{
						//System.out.println("ll "+ll.key+" pp "+pp.key);
						Node newSubtree=pp;
						while(!newSubtree.isLeaf()){
							newSubtree=newSubtree.left;
						}
						System.out.println("new "+newSubtree.key);
						parentExtra=new Node(newSubtree.key,newSubtree.value,newSubtree.weight,pp.extra,subtree.extra,subtree.extra.op);
												
						/* Node parentRight=new Node(pp.extra);
						Node parentLeft=new Node(pp.left);
						parentExtra.right=parentRight;
						parentExtra.left=parentLeft; */
						//create updated live tree
						Node updated=new Node(pp.key,pp.value,pp.weight,pp.left,pp.right,pp.op,pp.gen);
						newP=new Node(gpp.key,gpp.value,gpp.weight,gpp.left,updated,gpp.op,gpp.gen);
						
						System.out.println("2updated "+updated.key+updated.value+"/"+updated.left.key+updated.left.value+"/"+updated.right.key+updated.right.key);

						if (!weakLLX(gpp, 0, opsArray, nodesArray)) return null;

						/* System.out.println("newP "+newP.key+" parentExtra "+parentExtra.key +"left "+parentExtra.left.key
								+" leftleft "+parentExtra.left.left.key+" leftleftleft "+parentExtra.left.left.left.key );

						System.out.println("newP "+newP.key+" parentExtra "+parentExtra.key +"right "+parentExtra.right.key
								+" rightright "+parentExtra.right.right.key+" rightleft "+parentExtra .right.left.key );*/
					}
				}else { 

					// built bottom up

					//new is less than old extra
					if(k.compareTo((K)pp.extra.key)<0){
						//create extra subtree
						parentExtra=new Node(pp.extra);
						Node parentRight=new Node(pp.extra);
						Node parentLeft=new Node(pp.left);
						parentExtra.right=parentRight;
						parentExtra.left=parentLeft;
						//create updated live tree
						Node updated=new Node(key,value,ll.weight,ll.left,ll.right,ll.op,ll.gen);
						newP=new Node(pp.key,pp.value,pp.weight,updated,pp.right,pp.op,pp.gen);
						System.out.println("else1 "+key +value);
						//System.out.println("3updated "+updated.key+updated.value+"/"+updated.left.key+updated.left.value+"/"+updated.right.key+updated.right.key);

					}else{
						parentExtra=new Node(pp.right);
						Node parentRight=new Node(pp.right);
						Node parentLeft=new Node(pp.extra);
						parentExtra.right=parentRight;
						parentExtra.left=parentLeft;

						//update the live tree
						Node updated=new Node(key,value,ll.weight,ll.left,ll.right,ll.op,ll.gen);
						newP=new Node(pp.key,pp.value,pp.weight,pp.left,updated,pp.op,pp.gen);
						System.out.println("else2");
						//System.out.println("4updated "+updated.key+updated.value+"/"+updated.left.key+updated.left.value+"/"+updated.right.key+updated.right.key);
					}
				}
				//create normal subtree
				//pp.extra=null;
				//nodesArray.add(0,null);
				//opsArray.add(0,null);

				ll=pp;
				pp=gpp;
				gpp=gpp.parent;				


				//System.out.println("parent "+gpp.key+gpp.value);


				if (!weakLLX(gpp, 0, opsArray, nodesArray)) return null;
				//if (!weakLLX(p, 1, ops, nodes)) return null;

				dir = (ll==pp.left) ? LEFT : RIGHT;

				if(dir==LEFT){
					System.out.println("d");
					subtree=new Node(pp.key,pp.value,pp.weight,newP,pp.right,pp.op,pp.gen);
				}
				else{
					System.out.println("f");
					subtree=new Node(pp.key,pp.value,pp.weight,pp.left,newP,pp.op,pp.gen);
				}
				
				//System.out.println("################## " + subtree.key + " L = " + subtree.left.key + " R = " + subtree.right.key);

				
				//System.out.println(parentExtra.key  + " ***** "+ parentExtra.left.key + " ***** " +parentExtra.right.key);
				subtree.extra=parentExtra;
				subtree.extraDir=dir;
				subtree.parent = pp.parent;
				
				System.out.println("pp parent " + pp.parent.key);
				System.out.println(pp.parent.key + " - " + subtree.key);
				
//				Comparable<?super K> ku = comparable((K)subtree.key);
//				if(ku.compareTo((K)pp.parent.key) < 0){
//					pp.parent.left = subtree;
//				}else
//					pp.parent.right = subtree;
				

				System.out.println("subtree loop: "+subtree.key+"/"+subtree.value+"/"+subtree.left.key+"/"+subtree.right.key+"/");

				if(subtree.extra.left!=null && subtree.extra.right!=null){
					System.out.println("subtree extra if: "+subtree.key+"/"+subtree.value+"/"+subtree.extra.key+"/"+subtree.extra.left.key+
					subtree.extra.left.value+"/"
					+subtree.extra.right.key+subtree.extra.right.value);
				}
				//System.out.println("subtree extra: "+subtree.extra.key+"/"+subtree.extra.value+"/"+subtree.extra+"/"+subtree.extra+"/");

			}
		}
		//System.out.println("subtree "+subtree.key+" "+subtree.left.key+subtree.left.value+" "+subtree.right.key+" "+subtree.extra.key+subtree.extra.value);

		//System.out.println("sub "+subtree.key+"-"+subtree.value+"-"+subtree.gen+"-"+subtree.lastGen+" / extra"+subtree.extra.key+"-"+subtree.extra.value+"-"+subtree.extra.gen+"-"+subtree.extra.lastGen);
		Node[] nodesArr = new Node[nodesArray.size()];
		nodesArr = nodesArray.toArray(new Node[0]);

		Operation[] opsArr = new Operation[opsArray.size()];
		opsArr = opsArray.toArray(new Operation[0]);

		return new Operation(nodesArr, opsArr, subtree);
	}

	/* 


	private Operation createReplaceOp(final Node p, final Node l, final K key, final V value,int startGen,int leafGen) {

		Operation[] ops = new Operation[]{null};// added a null/ was final
		Node[] nodes = new Node[]{null, l}; // added p/ was final

		Node parent =p;
		Node pChild=l;
		if(startGen!=leafGen){


			final ArrayList<Operation> opps=new ArrayList();
			final ArrayList<Node> noddes=new ArrayList();
			noddes.add(l);

			while(parent.extra!=null){
				char dir = (parent.left==pChild) ? LEFT : RIGHT;
				final Node child=new Node(key,value,pChild.weight,null,null,dummy,startGen);//add generation
				if(dir==LEFT){
					final Node subtree = new Node(key, value, parent.weight, parent.extra,child, parent.op,startGen);//maybe dummy and gen
				}else{
					final Node subtree = new Node(key, value, parent.weight, child,parent.extra, parent.op,startGen);//maybe dummy and gen
				}
				noddes.add(parent);
				opps.add(parent.op);
				pChild=parent;
				parent=parent.parent;

			}

			final Node subtree = new Node(parent.key, parent.value, parent.weight, parent.left, parent.right, dummy);// maybe parent.op
			char dir = (parent.left==pChild) ? LEFT : RIGHT;
			int weight=pChild.weight;
			subtree.extra=new Node(key,value,weight,null,null,dummy,startGen);
			subtree.extraDir=dir;

			ops=new Operation[opps.size()];
			ops=opps.toArray(ops);

			nodes=new Node[noddes.size()];
			nodes=noddes.toArray(nodes);

		}else{
			// Build new sub-tree
			final Node subtree = new Node(key, value, l.weight, l.left, l.right, dummy);
			//add parent pointer
			subtree.parent = p;
		}

		if (!weakLLX(parent, 0, ops, nodes)) return null;

		if (pChild != parent.left && pChild != parent.right) return null;

		// Build new sub-tree
		//final Node subtree = new Node(key, value, l.weight, l.left, l.right, dummy);

		return new Operation(nodes, ops, subtree);

	} */

	/* 

	private Operation createReplaceOp(SearchRecord searchRecord, final K key, final V value) {
		Operation[] ops = new Operation[]{null};// added a null/ was final
		Node[] nodes = new Node[]{null, l}; // added p/ was final

		Node parent = searchRecord.parent;
		Node pChild=searchRecord.n;
		if(searchRecord.copy){// copy is true when extra pointer is needed


		final ArrayList<Operation> opps=new ArrayList();
		final ArrayList<Node> noddes=new ArrayList();
		noddes.add(l);

		if(parent.extra==null){
			char dir = (parent.left==pChild) ? LEFT : RIGHT;
			final Node child=new Node(pChild.key,pChild.value,pChild.weight,null,null,dummy,pChild.gen);//add generation
			final Node subtree = new Node(parent.key, parent.value, parent.weight, parent.left,parent.right, parent.op,parent.gen);//maybe dummy and gen
			subtree.extra=child;
			subtree.dir=dir;
			/* noddes.add(parent);
			opps.add(parent.op);
			pChild=parent;
			parent=parent.parent; 

		}else{
			while(parent.extra!=null){
				char dir = parent.dir;

				final Node child=new Node(pChild.key,pChild.value,pChild.weight,null,null,dummy,pChild.gen);//add generation
				final Node subtree = new Node(parent.key, parent.value, parent.weight, parent.left,parent.right, parent.op,parent.gen);//maybe dummy and gen
				subtree.extra=child;
				subtree.dir=dir;
				/* noddes.add(parent);
			opps.add(parent.op);
			pChild=parent;
			parent=parent.parent; 

			}else{
				while(parent.extra!=null){
					char dir = parent.dir;
					final Node child=new Node(pChild.key,pChild.value,pChild.weight,null,null,dummy,pChild.gen);//add generation
					final Node subtree = new Node(parent.key, parent.value, parent.weight, parent.left,parent.right, parent.op,parent.gen);//maybe dummy and gen
					subtree.extra=child;
					subtree.dir=dir;
				}
			}

			final Node subtree = new Node(parent.key, parent.value, parent.weight, parent.left, parent.right, dummy);// maybe parent.op
			char dir = (parent.left==pChild) ? LEFT : RIGHT;
			int weight=pChild.weight;
			subtree.extra=new Node(key,value,weight,null,null,dummy,startGen);
			subtree.extraDir=dir;

			ops=new Operation[opps.size()];
			ops=opps.toArray(ops);

			nodes=new Node[noddes.size()];
			nodes=noddes.toArray(nodes);

		}else{
			// Build new sub-tree
			final Node subtree = new Node(key, value, l.weight, l.left, l.right, dummy);
			//add parent pointer
			subtree.parent = p;
		}

		if (!weakLLX(parent, 0, ops, nodes)) return null;

		if (pChild != parent.left && pChild != parent.right) return null;

		// Build new sub-tree
		//final Node subtree = new Node(key, value, l.weight, l.left, l.right, dummy);

		return new Operation(nodes, ops, subtree);

	} 

	 */
	private V newDoPut(final K key, final V value, final boolean onlyIfAbsent) { // update fixToKey
		//System.out.println("beg");
		final Comparable<? super K> k = comparable(key);
		boolean found = false;
		Operation op = null;
		Node p = null, l = null;
		int count = 0;
		SearchRecord searchRecord=null;

		while (true) {
			while (op == null) {
				//System.out.println("search");
				searchRecord= search(key,false);
				//System.out.println("read");

				if(searchRecord.grandParent != null && k.compareTo((K) searchRecord.n.key) == 0){
					found = true;
					if (onlyIfAbsent) return (V) searchRecord.n.value;
					if(searchRecord.n.lastGen == searchRecord.startGen){
						//System.out.println("intra");
						op = createReplaceOp(searchRecord.parent, searchRecord.n, value,searchRecord.startGen);//update replaceop so it uses extra						
						//System.out.println("normal");
					}
					else{

						op = createReplaceOpReal(searchRecord.grandParent,searchRecord.parent, searchRecord.n, key,value,searchRecord.startGen);
						
						//System.out.println("extra ordinary");
					}
				} else {
					//System.out.println("else");
					//System.out.println("kelso");
					found = false;
					//searchRecord.leafGen=searchRecord.n.gen;
					op = createInsertOp(searchRecord.parent, searchRecord.n, key, value, k,searchRecord.startGen);
				}
				op.nodeList = searchRecord.nodeList;
				op.directionList = searchRecord.directionList;
			}
			if (helpSCXX(op)) {
				// clean up violations if necessary
				if (d == 0) {
					if (!found && (searchRecord.parent.weight == 0 )&& searchRecord.n.weight == 1) fixToKey(k);
				} else {
					if (searchRecord.violations >= d) fixToKey(k);
				}

				//System.out.println("help "+op.state+ " "+ searchRecord.n.gen+searchRecord.n.marked);
				//searchRecord.n.parent = null;
				// we may have found the key and replaced its value (and, if so, the old value is stored in the old node)
				return (found ? (V) searchRecord.n.value : null);
			}
			System.out.println("fail");
			//System.out.println("scx");
			op = null;
		}
	}

	public final V newRemove(final K key, int n) {
		final Comparable<? super K> k = comparable(key);
		Node gp, p = null, l = null;
		Operation op = null;
		int count = 0;
		SearchRecord searchRecord=null;

		while (true) {
			while (op == null) {
				searchRecord=search(key,false); // check loop (ifra method or outter)
				// the key was not in the tree at the linearization point, so no value was removed
				if (searchRecord.grandParent == null || k.compareTo((K) searchRecord.n.key) != 0) return null;
				if(searchRecord.n.lastGen==searchRecord.startGen){ // maybe save extra somewhere
					//System.out.println(searchRecord.n.lastGen+" - "+searchRecord.startGen);
					op = createDeleteOp(searchRecord.grandParent, searchRecord.parent, searchRecord.n);
					//System.out.println("normal");
				}
				else{
					op = createDeleteOpSnap(searchRecord.grandParent, searchRecord.parent, searchRecord.n,searchRecord.startGen);
					//op = createDeleteOpSnapLoop(searchRecord.grandParent, searchRecord.parent, searchRecord.n,searchRecord.startGen);
					//System.out.println("panormal");
				}
			}
			if (helpSCXX(op)) {
				// clean up violations if necessary
				if (d == 0) {
					if (searchRecord.parent.weight > 0 && searchRecord.n.weight > 0 && !isSentinel(searchRecord.parent)) fixToKey(k);
				} else {
					if (searchRecord.violations >= d) fixToKey(k);
				}

				//add parent pointer ---- should be inside removeOperation
				searchRecord.n.parent=null;
				searchRecord.parent.parent=null;
				// we deleted a key, so we return the removed value (saved in the old node)
				return (V) searchRecord.n.value;
			}
			op = null;
		}
	}




	//--------------------------------------------------------------------------
	//-------------------------end of our contribution--------------------------

	public final V put(final K key, final V value) {
		return newDoPut(key, value, false);
	}

	public final V putIfAbsent(final K key, final V value) {
		return doPut(key, value, true);
	}

	private V doPut(final K key, final V value, final boolean onlyIfAbsent) {
		final Comparable<? super K> k = comparable(key);
		boolean found = false;
		Operation op = null;
		Node p = null, l = null;
		int count = 0;

		while (true) {
			while (op == null) {
				p = root;
				l = root.left;
				if (l.left != null) {
					count = 0;
					p = l;
					l = l.left; // note: before executing this line, l must have key infinity, and l.left must not.
					while (l.left != null) {
						if (d > 0 && (l.weight > 1 || l.weight == 0 && p.weight == 0)) ++count;
						p = l;
						l = (k.compareTo((K) l.key) < 0) ? l.left : l.right;
						//l = (k.compareTo((K) l.key) < 0) ? l.right : l.left;//**MUTATION
					}
				}

				// if we find the key in the tree already
				if (l.key != null && k.compareTo((K) l.key) == 0) {
					found = true;
					if (onlyIfAbsent) return (V) l.value;
					op = createReplaceOp(p, l, key, value);
				} else {
					found = false;
					//op = createInsertOp(p, l, key, value, k);					
				}
			}
			if (helpSCX(op, 0)) {
				// clean up violations if necessary
				if (d == 0) {
					if (!found && p.weight == 0 && l.weight == 1) fixToKey(k);
				} else {
					if (count >= d) fixToKey(k);
				}
				//change parent pointer 
				l.parent = null;

				// we may have found the key and replaced its value (and, if so, the old value is stored in the old node)
				return (found ? (V) l.value : null);
			}
			op = null;
		}
	}

	public final V remove(final K key, int n) {
		final Comparable<? super K> k = comparable(key);
		Node gp, p = null, l = null;
		Operation op = null;
		int count = 0;

		while (true) {
			while (op == null) {
				gp = root;
				p = root;
				l = root.left;
				if (l.left != null) {
					count = 0;
					gp = p;
					p = l;
					l = l.left; // note: before executing this line, l must have key infinity, and l.left must not.
					while (l.left != null) {
						if (d > 0 && (l.weight > 1 || l.weight == 0 && p.weight == 0)) ++count;
						gp = p;
						p = l;
						l = (k.compareTo((K) l.key) < 0) ? l.left : l.right;
					}
				}

				// the key was not in the tree at the linearization point, so no value was removed
				if (l.key == null || k.compareTo((K) l.key) != 0) return null;
				op = createDeleteOp(gp, p, l);
				//remove parent pointer
				l.parent = null;
			}
			if (helpSCX(op, 0)) {
				// clean up violations if necessary
				if (d == 0) {
					if (p.weight > 0 && l.weight > 0 && !isSentinel(p)) fixToKey(k);
				} else {
					if (count >= d) fixToKey(k);
				}
				// we deleted a key, so we return the removed value (saved in the old node)
				return (V) l.value;
			}
			op = null;
		}
	}

	public final void fixToKey(final Comparable<? super K> k) {
		while (true) {
			Node ggp, gp, p, l = root.left;
			if (l.left == null) return; // only sentinels in tree...
			ggp = gp = root;
			p = l;
			l = l.left; // note: before executing this line, l must have key infinity, and l.left must not.
			while (l.left != null && l.weight <= 1 && (l.weight != 0 || p.weight != 0)) {
				ggp = gp;
				gp = p;
				p = l;
				l = (k.compareTo((K) l.key) < 0) ? l.left : l.right;
			}
			if (l.weight == 1) return; // if no violation, then the search hit a leaf, so we can stop

			final Operation op = createBalancingOp(ggp, gp, p, l);
			if (op != null) {
				helpSCX(op, 0);
			}
		}
	}

	@SuppressWarnings("unchecked")
	private Comparable<? super K> comparable(final Object key) {
		if (key == null) {
			throw new NullPointerException();
		}
		if (comparator == null) {
			return (Comparable<? super K>)key;
		}
		return new Comparable<K>() {
			@SuppressWarnings("unchecked")
			public int compareTo(final K rhs) { return comparator.compare((K)key, rhs); }
		};
	}

	private boolean isSentinel(final Node node) {
		return (node.key == null || node == root.left.left);
	}

	// This weaker form of LLX does not return a linearizable snapshot.
	// However, we do not use the fact that LLX returns a snapshot anywhere in
	//   the proof of SCX (help), and we do not need the snapshot capability
	//   to satisfy the precondition of SCX (that there be an LLX linked to SCX
	//   for each node in V).
	// Note: using a full LLX slows things by ~3%.
	private Operation weakLLX(final Node r) {
		final Operation rinfo = r.op;
		final int state = rinfo.state;
		if (state == Operation.STATE_ABORTED || (state == Operation.STATE_COMMITTED )) {//!r.marked
			//System.out.println("state "+state+" "+r.marked);
			return rinfo;
		}
		if (rinfo.state == Operation.STATE_INPROGRESS) {
			helpSCX(rinfo, 1);
		} else if (r.op.state == Operation.STATE_INPROGRESS) {
			helpSCX(r.op, 1);
		}
		//System.out.println("node "+state+" "+r.marked);
		//System.out.println("null");
		return null;
	}
	// helper function to use the results of a weakLLX more conveniently
	private boolean weakLLX(final Node r, final int i, final Operation[] ops, final Node[] nodes) {
		if ((ops[i] = weakLLX(r)) == null) return false;
		nodes[i] = r;
		//System.out.println("here "+ops[i].state+ " "+r.marked);
		return true;
	}

	private boolean weakLLX(final Node r, final int i, final ArrayList<Operation> ops, final ArrayList<Node> nodes) {
		ops.add(i,weakLLX(r));
		if ((ops.get(i)) == null) return false;
		nodes.add(i,r);
		//System.out.println("here "+ops[i].state+ " "+r.marked);
		return true;
	}
	
	private boolean weakLLX(final Node r, final ArrayList<Operation> ops, final ArrayList<Node> nodes) {
		ops.add(weakLLX(r));
		if ((ops.get(ops.size()-1)) == null) return false; // check -1
		nodes.add(r);
		//System.out.println("here "+ops[i].state+ " "+r.marked);
		return true;
	}

	// this function is essentially an SCX without the creation of V, R, fld, new
	// (which are stored in an operation object).
	// the creation of the operation object is simply inlined in other methods.
	private boolean helpSCX(final Operation op, int i) {
		// get local references to some fields of op, in case we later null out fields of op (to help the garbage collector)
		final Node[] nodes = op.nodes;
		final Operation[] ops = op.ops;
		final Node subtree = op.subtree;
		// if we see aborted or committed, no point in helping (already done).
		// further, if committed, variables may have been nulled out to help the garbage collector.
		// so, we return.
		if (op.state != Operation.STATE_INPROGRESS) return true;

		// freeze sub-tree -- vlx
		for (; i<ops.length; ++i) {
			if (!updateOp.compareAndSet(nodes[i], ops[i], op) && nodes[i].op != op) { // if work was not done
				if (op.allFrozen) {
					return true;
				} else {
					op.state = Operation.STATE_ABORTED;
					// help the garbage collector (must be AFTER we set state committed or aborted)
					op.nodes = null;
					op.ops = null;
					op.subtree = null;
					return false;
				}
			}
		}
		op.allFrozen = true;
		for (i=1; i<ops.length; ++i) nodes[i].marked = true; // finalize all but first node

		// CAS in the new sub-tree (child-cas)
		if (nodes[0].left == nodes[1]) {
			updateLeft.compareAndSet(nodes[0], nodes[1], subtree);     // splice in new sub-tree (as a left child)
		} else { // assert: nodes[0].right == nodes[1]
			updateRight.compareAndSet(nodes[0], nodes[1], subtree);    // splice in new sub-tree (as a right child)
		}
		op.state = Operation.STATE_COMMITTED;

		// help the garbage collector (must be AFTER we set state committed or aborted)
		op.nodes = null;
		op.ops = null;
		op.subtree = null;
		if(op.updateSnapshot){ // only do this when a gcas has happened
			Node node=snapList.get(maxSnapId);
			
			for(int x=0;x<op.nodeList ;x++){
				char dir=op.directionList(x);
				Node l=(dir==LEFT) ? node.left : node.right;
				if(node.gen==l.gen){
					if(dir==LEFT){
						node.left=op.nodeList(x);
						node=node.left;
					}
					else{
						node.right=op.nodeList(x);
						node=node.right;
					}
				}else{
					if(dir==LEFT)
						node=node.left;
					else
						node=node.right;
				}
			}
		}
		
		
		return true;
	}

	private Operation createInsertOp(final Node p, final Node l, final K key, final V value, Comparable k,int generation) {
		final Operation[] ops = new Operation[]{null};
		final Node[] nodes = new Node[]{null, l};

		if (!weakLLX(p, 0, ops, nodes)) return null;
		//System.out.println("insertOp"+ops[0].state+" "+p.marked);

		if (l != p.left && l != p.right) return null;

		// Compute the weight for the new parent node
		final int newWeight = (isSentinel(l) ? 1 : l.weight - 1);               // (maintain sentinel weights at 1)


		// Build new sub-tree
		final Node newLeaf = new Node(key, value, 1, null, null, dummy);
		newLeaf.lastGen=generation;
		newLeaf.gen = generation;
		final Node newL = new Node(l.key, l.value, 1, null, null, dummy);
		//update generation
		newL.gen = l.gen;
		newL.lastGen = l.lastGen;

		final Node newP;
		if (l.key == null || k.compareTo(l.key) < 0) {
			newP = new Node(l.key, l.value, newWeight, newLeaf, newL, dummy);		
			newP.gen = l.gen;//add generation
			newP.lastGen = l.gen;//???

			//System.out.println("createInsertOp 1660 " + l.key + " " + l.value );
		} else {
			newP = new Node(key, value, newWeight, newL, newLeaf, dummy);
			newP.gen = generation;//add generation
			newP.lastGen = generation;//add generation
			//System.out.println("createInsertOp 1665 " );
		}

		// add parent pointer
		newP.parent = p;
		newLeaf.parent = newP;
		newL.parent = newP;

		//System.out.println();
		return new Operation( nodes, ops, newP);
	}

	private Operation createDeleteOpSnap(final Node gp, final Node p, final Node l,int gen) {
		final Operation[] ops = new Operation[]{null, null, null};
		final Node[] nodes = new Node[]{null, null, null};

		if (!weakLLX(gp, 0, ops, nodes)) return null;
		if (!weakLLX(p, 1, ops, nodes)) return null;

		if (p != gp.left && p != gp.right) return null;
		final boolean left = (l == p.left);
		if (!left && l != p.right) return null;

		// Read fields for the sibling of l into ops[2], nodes[2] = s
		if (!weakLLX(left ? p.right : p.left, 2, ops, nodes)) return null;
		final Node s = nodes[2];

		// Now, if the op. succeeds, all structure is guaranteed to be just as we verified

		// Compute weight for the new node (to replace to deleted leaf l and parent p)
		final int newWeight = (isSentinel(p) ? 1 : p.weight + s.weight); // weights of parent + sibling of deleted leaf

		// Build new sub-tree
		final Node newP = new Node(s.key, s.value, newWeight, s.left, s.right, dummy);
		newP.gen=gen;


		newP.parent = gp;

		//create extra
		Node extra=new Node(l);
		extra.gen=gen;
		extra.lastGen=gen-1;
		newP.extra=extra;
		Comparable<K> k = (Comparable<K>) comparable(l.key);
		if(k.compareTo((K)newP.key) >= 0){
			newP.extraDir = RIGHT;
		}else{
			newP.extraDir = LEFT;
		}

		//newP.extraDir = ???
		//		System.out.println("deletion baby "+newP.extra.key+" "+newP.extra.lastGen+" "+newP.extra.gen);
		//		System.out.println("all :"+newP.key
		//				+" "+newP.left+
		//				" "+newP.right+" "+
		//				newP.extra.key);



		return new Operation(nodes, ops, newP);
	}
	
	private Operation createDeleteOpSnapLoop(final Node gp, final Node p, final Node l,int gen) {
		final Operation[] ops = new Operation[]{null, null, null};
		final Node[] nodes = new Node[]{null, null, null};
		
		if (!weakLLX(gp, 0, ops, nodes)) return null;
		if (!weakLLX(p, 1, ops, nodes)) return null;
		
		if (p != gp.left && p != gp.right) return null;
		final boolean left = (l == p.left);
		if (!left && l != p.right) return null;
		
		//traverse the tree to get the list of node from root to the target node l
		
		Node temp = root.left.left;
		ArrayList listDirection = new ArrayList();//list of direction from root to target node l
		ArrayList<Node> listNodes = new ArrayList<Node>();//list of node from root to l
		Comparable<?super K> comp = comparable(l.key);
		while(temp!=null){
			char dir= (comp.compareTo((K)temp.key)<0) ? LEFT : RIGHT;
			listNodes.add(temp);
			if(dir == LEFT)
				temp = temp.left;
			else
				temp = temp.right;
			listDirection.add(dir);						
		}
		int indexListDirection = listDirection.size() - 1;
		int indexListNodes = listNodes.size() - 1;
		
		if (!weakLLX(left ? p.right : p.left, 2, ops, nodes)) return null;
		
		//if node's parent extra pointer is null
		final Node s = nodes[2];

		// Compute weight for the new node (to replace to deleted leaf l and parent p)
		final int newWeight = (isSentinel(p) ? 1 : p.weight + s.weight); // weights of parent + sibling of deleted leaf
		
		final Node newP;
		if(l.extra == null && p.extra == null){// ***if the node l does not have extra pointer and so does its parent						
			// Build new sub-tree
			newP = new Node(s.key, s.value, newWeight, s.left, s.right, dummy, s.gen);
			newP.lastGen = s.gen;
			final Node newExtraChild = new Node(l.key, l.value, l.weight, l.left, l.right, dummy, l.gen);//need to be checked newExtraChild.left and newExtraChild.right
			newExtraChild.lastGen = l.lastGen;
			newP.extra = newExtraChild;
			newP.extraDir = left ? LEFT:RIGHT;		
			
			return new Operation(nodes, ops, newP);	
			
		}else if (l.extra != null && s.extra == null){// ***if the node l has extra pointer and its parent does not
			if(p.extra == null){
					newP = new Node(s.key, s.value, newWeight, s.left, s.right, dummy);
					final Node newExtraChild;
					if(l.extraDir == LEFT){
						newExtraChild = new Node(l.key, l.value, l.weight, l.extra, l, dummy, l.gen);
						newExtraChild.lastGen = l.lastGen;
					}else{
						newExtraChild = new Node(l.extra.key, l.extra.value, l.extra.weight, l, l.extra.right, dummy, l.extra.gen);
						newExtraChild.lastGen = l.extra.lastGen;
					}
					newP.extra = newExtraChild;
					newP.extraDir = left ? LEFT: RIGHT;				
					return new Operation(nodes, ops, newP);
			}
				
		}else if (l.extra != null && s.extra != null){// ***if the node l has extra pointer and so does its sibling
					newP = new Node(s.key, s.value, newWeight, s.left, s.right, dummy);
					final Node lExtra;
					if(l.extraDir == LEFT){
						lExtra = new Node(l.key, l.value, l.weight, l.extra, l , dummy);
					}else{
						lExtra = new Node(l.extra.key, l.extra.value, l.weight, l, l.extra.right , dummy);
					}
					final Node newExtraChild;
					if(left){
						newExtraChild = new Node(p.key, p.value, newWeight, lExtra, s.extra, dummy);//should be checked		
					}else{
						newExtraChild = new Node(p.key, p.value, newWeight, s.extra, lExtra, dummy);//should be checked
					}
					newExtraChild.lastGen = p.lastGen;
					newP.extra = newExtraChild;
					newP.extraDir = (left) ? LEFT: RIGHT;
					return new Operation(nodes, ops, newP);
			
		}
		return null;
			
	}


	// Just like insert, except this replaces any existing value.
	private Operation createReplaceOp(final Node p, final Node l, final K key, final V value) {
		final Operation[] ops = new Operation[]{null};
		final Node[] nodes = new Node[]{null, l};

		if (!weakLLX(p, 0, ops, nodes)) return null;

		if (l != p.left && l != p.right) return null;

		// Build new sub-tree
		final Node subtree = new Node(key, value, l.weight, l.left, l.right, dummy);

		//add parent pointer
		subtree.parent = p;

		return new Operation(nodes, ops, subtree);
	}

	// Just like insert, except this replaces any existing value.
	private Operation createReplaceOp(final Node p, final Node l, final V value,final int gen) {
		final Operation[] ops = new Operation[]{null};
		final Node[] nodes = new Node[]{null, l};

		if (!weakLLX(p, 0, ops, nodes)) return null;

		if (l != p.left && l != p.right) return null;

		// Build new sub-tree
		final Node subtree = new Node(l.key, value, l.weight, l.left, l.right, dummy);

		//add parent pointer
		subtree.parent = p;

		return new Operation(nodes, ops, subtree);
	}

	private Operation createDeleteOp(final Node gp, final Node p, final Node l) {
		final Operation[] ops = new Operation[]{null, null, null};
		final Node[] nodes = new Node[]{null, null, null};

		if (!weakLLX(gp, 0, ops, nodes)) return null;
		if (!weakLLX(p, 1, ops, nodes)) return null;

		if (p != gp.left && p != gp.right) return null;
		final boolean left = (l == p.left);
		if (!left && l != p.right) return null;

		// Read fields for the sibling of l into ops[2], nodes[2] = s
		if (!weakLLX(left ? p.right : p.left, 2, ops, nodes)) return null;
		final Node s = nodes[2];

		// Now, if the op. succeeds, all structure is guaranteed to be just as we verified

		// Compute weight for the new node (to replace to deleted leaf l and parent p)
		final int newWeight = (isSentinel(p) ? 1 : p.weight + s.weight); // weights of parent + sibling of deleted leaf

		// Build new sub-tree
		final Node newP = new Node(s.key, s.value, newWeight, s.left, s.right, dummy);

		//add parent pointer
		newP.parent = gp;
		return new Operation(nodes, ops, newP);
	}

	private Operation createBalancingOp(final Node f, final Node fX, final Node fXX, final Node fXXX) {
		final Operation opf = weakLLX(f);
		if (opf == null || !f.hasChild(fX)) return null;

		final Operation opfX = weakLLX(fX);
		if (opfX == null) return null;
		final Node fXL = fX.left;
		final Node fXR = fX.right;
		final boolean fXXleft = (fXX == fXL);
		if (!fXXleft && fXX != fXR) return null;

		final Operation opfXX = weakLLX(fXX);
		if (opfXX == null) return null;
		final Node fXXL = fXX.left;
		final Node fXXR = fXX.right;
		final boolean fXXXleft = (fXXX == fXXL);
		if (!fXXXleft && fXXX != fXXR) return null;

		// Overweight violation
		if (fXXX.weight > 1) {
			if (fXXXleft) {
				final Operation opfXXL = weakLLX(fXXL);
				if (opfXXL == null) return null;
				return createOverweightLeftOp(f, fX, fXX, fXXL, opf, opfX, opfXX, opfXXL, fXL, fXR, fXXR, fXXleft);

			} else {
				final Operation opfXXR = weakLLX(fXXR);
				if (opfXXR == null) return null;
				return createOverweightRightOp(f, fX, fXX, fXXR, opf, opfX, opfXX, opfXXR, fXR, fXL, fXXL, !fXXleft);
			}
			// Red-red violation
		} else {
			if (fXXleft) {
				if (fXR.weight == 0) {
					final Operation opfXR = weakLLX(fXR);
					if (opfXR == null) return null;
					return createBlkOp(new Node[] {f, fX, fXX, fXR}, new Operation[] {opf, opfX, opfXX, opfXR});

				} else if (fXXXleft) {
					return createRb1Op(new Node[] {f, fX, fXX}, new Operation[] {opf, opfX, opfXX});

				} else {
					final Operation opfXXR = weakLLX(fXXR);
					if (opfXXR == null) return null;
					return createRb2Op(new Node[] {f, fX, fXX, fXXR}, new Operation[] {opf, opfX, opfXX, opfXXR});
				}
			} else {
				if (fXL.weight == 0) {
					final Operation opfXL = weakLLX(fXL);
					if (opfXL == null) return null;
					return createBlkOp(new Node[] {f, fX, fXL, fXX}, new Operation[] {opf, opfX, opfXL, opfXX});

				} else if (!fXXXleft) {
					return createRb1SymOp(new Node[] {f, fX, fXX}, new Operation[] {opf, opfX, opfXX});

				} else {
					final Operation opfXXL = weakLLX(fXXL);
					if (opfXXL == null) return null;
					return createRb2SymOp(new Node[] {f, fX, fXX, fXXL}, new Operation[] {opf, opfX, opfXX, opfXXL});
				}
			}
		}
	}

	private Operation createOverweightLeftOp(final Node f,
			final Node fX,
			final Node fXX,
			final Node fXXL,
			final Operation opf,
			final Operation opfX,
			final Operation opfXX,
			final Operation opfXXL,
			final Node fXL,
			final Node fXR,
			final Node fXXR,
			final boolean fXXlef) {
		if (fXXR.weight == 0) {
			if (fXX.weight == 0) {
				if (fXXlef) {
					if (fXR.weight == 0) {
						final Operation opfXR = weakLLX(fXR);
						if (opfXR == null) return null;
						return createBlkOp(new Node[] {f, fX, fXX, fXR}, new Operation[] {opf, opfX, opfXX, opfXR});
					} else { // assert: fXR.weight > 0
						final Operation opfXXR = weakLLX(fXXR);
						if (opfXXR == null) return null;
						return createRb2Op(new Node[] {f, fX, fXX, fXXR}, new Operation[] {opf, opfX, opfXX, opfXXR});
					}
				} else { // assert: fXX == fXR
					if (fXL.weight == 0) {
						final Operation opfXL = weakLLX(fXL);
						if (opfXL == null) return null;
						return createBlkOp(new Node[] {f, fX, fXL, fXX}, new Operation[] {opf, opfX, opfXL, opfXX});
					} else {
						return createRb1SymOp(new Node[] {f, fX, fXX}, new Operation[] {opf, opfX, opfXX});
					}
				}
			} else { // assert: fXX.weight > 0
				final Operation opfXXR = weakLLX(fXXR);
				if (opfXXR == null) return null;

				final Node fXXRL = fXXR.left;
				final Operation opfXXRL = weakLLX(fXXRL);
				if (opfXXRL == null) return null;

				if (fXXRL.weight > 1) {
					return createW1Op(new Node[] {fX, fXX, fXXL, fXXR, fXXRL}, new Operation[] {opfX, opfXX, opfXXL, opfXXR, opfXXRL});
				} else if (fXXRL.weight == 0) {
					return createRb2SymOp(new Node[] {fX, fXX, fXXR, fXXRL}, new Operation[] {opfX, opfXX, opfXXR, opfXXRL});
				} else { // assert: fXXRL.weight == 1
					final Node fXXRLR = fXXRL.right;
					if (fXXRLR == null) return null;
					if (fXXRLR.weight == 0) {
						final Operation opfXXRLR = weakLLX(fXXRLR);
						if (opfXXRLR == null) return null;
						return createW4Op(new Node[] {fX, fXX, fXXL, fXXR, fXXRL, fXXRLR}, new Operation[] {opfX, opfXX, opfXXL, opfXXR, opfXXRL, opfXXRLR});
					} else { // assert: fXXRLR.weight > 0
						final Node fXXRLL = fXXRL.left;
						if (fXXRLL == null) return null;
						if (fXXRLL.weight == 0) {
							final Operation opfXXRLL = weakLLX(fXXRLL);
							if (opfXXRLL == null) return null;
							return createW3Op(new Node[] {fX, fXX, fXXL, fXXR, fXXRL, fXXRLL}, new Operation[] {opfX, opfXX, opfXXL, opfXXR, opfXXRL, opfXXRLL});
						} else { // assert: fXXRLL.weight > 0
							return createW2Op(new Node[] {fX, fXX, fXXL, fXXR, fXXRL}, new Operation[] {opfX, opfXX, opfXXL, opfXXR, opfXXRL});
						}
					}
				}
			}
		} else if (fXXR.weight == 1) {
			final Operation opfXXR = weakLLX(fXXR);
			if (opfXXR == null) return null;

			final Node fXXRL = fXXR.left;
			if (fXXRL == null) return null;
			final Node fXXRR = fXXR.right; // note: if fXXRR is null, then fXXRL is null, since tree is always a full binary tree, and children of leaves don't change
			if (fXXRR.weight == 0) {
				final Operation opfXXRR = weakLLX(fXXRR);
				if (opfXXRR == null) return null;
				return createW5Op(new Node[] {fX, fXX, fXXL, fXXR, fXXRR}, new Operation[] {opfX, opfXX, opfXXL, opfXXR, opfXXRR});
			} else if (fXXRL.weight == 0) {
				final Operation opfXXRL = weakLLX(fXXRL);
				if (opfXXRL == null) return null;
				return createW6Op(new Node[] {fX, fXX, fXXL, fXXR, fXXRL}, new Operation[] {opfX, opfXX, opfXXL, opfXXR, opfXXRL});
			} else {
				return createPushOp(new Node[] {fX, fXX, fXXL, fXXR}, new Operation[] {opfX, opfXX, opfXXL, opfXXR});
			}
		} else {
			final Operation opfXXR = weakLLX(fXXR);
			if (opfXXR == null) return null;
			return createW7Op(new Node[] {fX, fXX, fXXL, fXXR}, new Operation[] {opfX, opfXX, opfXXL, opfXXR});
		}
	}

	public static class Gen {
		private static int counter=0;
		public int gen;
		public Gen(){
			gen=counter;
			counter++;
		}
	}

	public static class Node {//this class first is declared as final
		public final int weight;
		public final Object value;
		public volatile boolean marked;
		public volatile Operation op;
		public final Object key;
		public volatile Node left, right;
		public volatile Node parent;
		// added for snapshot
		public volatile Node prev;
		public volatile boolean failed;
		public volatile int gen;
		public volatile int lastGen=-1;
		public volatile Node extra;
		public volatile char extraDir;

		public Node(final Object key, final Object value, final int weight, final Node left, final Node right, final Operation op) {
			this.key = key;
			this.value = value;
			this.weight = weight;
			this.left = left;
			this.right = right;
			this.op = op;
			this.extra = null;
		}

		public Node(final Object key, final Object value, final int weight, final Node left, final Node right, final Operation op, final int gen) {
			this.key = key;
			this.value = value;
			this.weight = weight;
			this.left = left;
			this.right = right;
			this.op = op;
			this.gen=gen;
			this.extra = null;
		}

		public Node(Node n,boolean failed) { // only use when failed
			this.key = n.key;
			this.value = n.value;
			this.weight = n.weight;
			this.left = n.left;
			this.right = n.right;
			this.op = n.op;
			this.prev=n.prev;
			this.failed=failed;
			this.extra = null;
		}

		public Node(Node n,int gen) { 
			this.key = n.key;
			this.value = n.value;
			this.weight = n.weight;
			this.left = n.left;
			this.right = n.right;
			this.op = n.op;
			this.prev=n.prev;
			this.gen=gen;
			this.extra = null;
		}

		public Node(Node n){
			this.key = n.key;
			this.value = n.value;
			this.weight = n.weight;
			this.left = n.left;
			this.right = n.right;
			this.op = n.op;
			this.prev=n.prev;
			this.gen=gen;
			this.extra = n.extra;
			this.lastGen=n.lastGen;
		}

		public final boolean hasChild(final Node node) {
			return node == left || node == right;
		}

		//added by us
		public boolean isLeaf(){
			return left==null && right==null;
		}

		public boolean equals(Node o) 
		{
			if (o instanceof Node) 
			{
				Node c = (Node) o;
				if(this.key.equals(c.key) && this.value.equals(c.value))
					return true;
			}
			return false;
		}
	}

	public static final class SearchRecord {
		public Node greatGrandParent;
		public Node grandParent;
		public Node parent;
		public Node n;
		public int startGen;
		public int violations;
		public int leafGen;
		public ArrayList<Node> nodeList;
		public ArrayList directionList;
		public boolean updateSnapshot = false;

		public SearchRecord(Node ggp,Node gp,Node p,Node n,int gen,int viol, ArrayList nodeList, ArrayList directionList, boolean updateSnapshot){
			greatGrandParent=ggp;
			grandParent=gp;
			parent=p;
			this.n=n;
			startGen=gen;
			violations=viol;
			this.nodeList = nodeList;
			this.directionList = directionList;
			this.updateSnapshot = updateSnapshot;			
		}

		public SearchRecord(Node ggp,Node gp,Node p,Node n,int gen){
			greatGrandParent=ggp;
			grandParent=gp;
			parent=p;
			this.n=n;
			startGen=gen;
			violations=0;
		}

	}

	//class Descriptor
	public static final class Descriptor extends Operation {
		//old: INode[K, V], expectedmain: MainNode[K, V], nv: INode[K, V]
		public Node oldValue;
		public Operation sentinelOp;
		public Node newValue;
		public volatile boolean committed  = false;
		public Descriptor(Node old, Operation exp, Node nv){
			//super(null,null,0,null,null,null);//call super class constructor
			super();
			oldValue = old;
			sentinelOp = exp;
			newValue = nv;
		}
	}

	public static class Operation {
		final static int STATE_INPROGRESS = 0;
		final static int STATE_ABORTED = 1;
		final static int STATE_COMMITTED = 2;
		// added steps
		final static int STEP_SUBTREE=0;
		final static int STEP_GENERATION=1;
		final static int STEP_COMMIT=2;
		final static int STEP_ABORT=3;


		volatile Node subtree;
		volatile Node[] nodes;
		volatile Operation[] ops;
		volatile int state;
		volatile int step;

		volatile int gen;
		volatile boolean allFrozen;
		
		ArrayList<Node> nodeList;
		ArrayList directionList;
		boolean updateSnapshot;

		public Operation() {            // create an inactive operation (a no-op) [[ we do this to avoid the overhead of inheritance ]]
			nodes = null; ops = null; subtree = null;
			this.state = STATE_ABORTED;   // cheap trick to piggy-back on a pre-existing check for active operations
		}

		public Operation(final Node[] nodes, final Operation[] ops, final Node subtree) {
			this.nodes = nodes;
			this.ops = ops;
			this.subtree = subtree;
		}

		public Operation(int state) {     // added by me
			nodes = null; ops = null; subtree = null;
			this.state = state;   
		}
	}

	/**
	 *
	 * Computer generated code
	 *
	 */

	private Operation createOverweightRightOp(final Node f,
			final Node fX,
			final Node fXX,
			final Node fXXR,
			final Operation opf,
			final Operation opfX,
			final Operation opfXX,
			final Operation opfXXR,
			final Node fXR,
			final Node fXL,
			final Node fXXL,
			final boolean fXXright) {
		if (fXXL.weight == 0) {
			if (fXX.weight == 0) {
				if (fXXright) {
					if (fXL.weight == 0) {
						final Operation opfXL = weakLLX(fXL);
						if (opfXL == null) return null;
						return createBlkOp(new Node[] {f, fX, fXL, fXX},
								new Operation[] {opf, opfX, opfXL, opfXX});
					} else { // assert: fXL.weight > 0
						final Operation opfXXL = weakLLX(fXXL);
						if (opfXXL == null) return null;
						return createRb2SymOp(new Node[] {f, fX, fXX, fXXL},
								new Operation[] {opf, opfX, opfXX, opfXXL});
					}
				} else { // assert: fXX == fXL
					if (fXR.weight == 0) {
						final Operation opfXR = weakLLX(fXR);
						if (opfXR == null) return null;
						return createBlkOp(new Node[] {f, fX, fXX, fXR},
								new Operation[] {opf, opfX, opfXX, opfXR});
					} else {
						return createRb1Op(new Node[] {f, fX, fXX},
								new Operation[] {opf, opfX, opfXX});
					}
				}
			} else { // assert: fXX.weight > 0
				final Operation opfXXL = weakLLX(fXXL);
				if (opfXXL == null) return null;

				final Node fXXLR = fXXL.right;
				final Operation opfXXLR = weakLLX(fXXLR);
				if (opfXXLR == null) return null;

				if (fXXLR.weight > 1) {
					return createW1SymOp(new Node[] {fX, fXX, fXXL, fXXR, fXXLR},
							new Operation[] {opfX, opfXX, opfXXL, opfXXR, opfXXLR});
				} else if (fXXLR.weight == 0) {
					return createRb2Op(new Node[] {fX, fXX, fXXL, fXXLR},
							new Operation[] {opfX, opfXX, opfXXL, opfXXLR});
				} else { // assert: fXXLR.weight == 1
					final Node fXXLRL = fXXLR.left;
					if (fXXLRL == null) return null;
					if (fXXLRL.weight == 0) {
						final Operation opfXXLRL = weakLLX(fXXLRL);
						if (opfXXLRL == null) return null;
						return createW4SymOp(new Node[] {fX, fXX, fXXL, fXXR, fXXLR, fXXLRL},
								new Operation[] {opfX, opfXX, opfXXL, opfXXR, opfXXLR, opfXXLRL});
					} else { // assert: fXXLRL.weight > 0
						final Node fXXLRR = fXXLR.right;
						if (fXXLRR == null) return null;
						if (fXXLRR.weight == 0) {
							final Operation opfXXLRR = weakLLX(fXXLRR);
							if (opfXXLRR == null) return null;
							return createW3SymOp(new Node[] {fX, fXX, fXXL, fXXR, fXXLR, fXXLRR},
									new Operation[] {opfX, opfXX, opfXXL, opfXXR, opfXXLR, opfXXLRR});
						} else { // assert: fXXLRR.weight > 0
							return createW2SymOp(new Node[] {fX, fXX, fXXL, fXXR, fXXLR},
									new Operation[] {opfX, opfXX, opfXXL, opfXXR, opfXXLR});
						}
					}
				}
			}
		} else if (fXXL.weight == 1) {
			final Operation opfXXL = weakLLX(fXXL);
			if (opfXXL == null) return null;

			final Node fXXLR = fXXL.right;
			if (fXXLR == null) return null;
			final Node fXXLL = fXXL.left; // note: if fXXLL is null, then fXXLR is null, since tree is always a full binary tree, and children of leaves don't change
			if (fXXLL.weight == 0) {
				final Operation opfXXLL = weakLLX(fXXLL);
				if (opfXXLL == null) return null;
				return createW5SymOp(new Node[] {fX, fXX, fXXL, fXXR, fXXLL},
						new Operation[] {opfX, opfXX, opfXXL, opfXXR, opfXXLL});
			} else if (fXXLR.weight == 0) {
				final Operation opfXXLR = weakLLX(fXXLR);
				if (opfXXLR == null) return null;
				return createW6SymOp(new Node[] {fX, fXX, fXXL, fXXR, fXXLR},
						new Operation[] {opfX, opfXX, opfXXL, opfXXR, opfXXLR});
			} else {
				return createPushSymOp(new Node[] {fX, fXX, fXXL, fXXR},
						new Operation[] {opfX, opfXX, opfXXL, opfXXR});
			}
		} else {
			final Operation opfXXL = weakLLX(fXXL);
			if (opfXXL == null) return null;
			return createW7SymOp(new Node[] {fX, fXX, fXXL, fXXR},
					new Operation[] {opfX, opfXX, opfXXL, opfXXR});
		}
	}

	private Operation createBlkOp(final Node[] nodes, final Operation[] ops) {
		final Node nodeXL = new Node(nodes[2].key, nodes[2].value, 1, nodes[2].left, nodes[2].right, dummy);
		final Node nodeXR = new Node(nodes[3].key, nodes[3].value, 1, nodes[3].left, nodes[3].right, dummy);
		final int weight = (isSentinel(nodes[1]) ? 1 : nodes[1].weight-1); // root of old subtree is a sentinel
		final Node nodeX = new Node(nodes[1].key, nodes[1].value, weight, nodeXL, nodeXR, dummy);
		return new Operation(nodes, ops, nodeX);
	}

	private Operation createRb1Op(final Node[] nodes, final Operation[] ops) {
		final Node nodeXR = new Node(nodes[1].key, nodes[1].value, 0, nodes[2].right, nodes[1].right, dummy);
		final int weight = nodes[1].weight;
		final Node nodeX = new Node(nodes[2].key, nodes[2].value, weight, nodes[2].left, nodeXR, dummy);
		return new Operation(nodes, ops, nodeX);
	}

	private Operation createRb2Op(final Node[] nodes, final Operation[] ops) {
		final Node nodeXL = new Node(nodes[2].key, nodes[2].value, 0, nodes[2].left, nodes[3].left, dummy);
		final Node nodeXR = new Node(nodes[1].key, nodes[1].value, 0, nodes[3].right, nodes[1].right, dummy);
		final int weight = nodes[1].weight;
		final Node nodeX = new Node(nodes[3].key, nodes[3].value, weight, nodeXL, nodeXR, dummy);
		return new Operation(nodes, ops, nodeX);
	}

	private Operation createPushOp(final Node[] nodes, final Operation[] ops) {
		final Node nodeXXL = new Node(nodes[2].key, nodes[2].value, nodes[2].weight-1, nodes[2].left, nodes[2].right, dummy);
		final Node nodeXXR = new Node(nodes[3].key, nodes[3].value, 0, nodes[3].left, nodes[3].right, dummy);
		final int weight = (isSentinel(nodes[1]) ? 1 : nodes[1].weight+1); // root of old subtree is a sentinel
		final Node nodeXX = new Node(nodes[1].key, nodes[1].value, weight, nodeXXL, nodeXXR, dummy);
		return new Operation(nodes, ops, nodeXX);
	}

	private Operation createW1Op(final Node[] nodes, final Operation[] ops) {
		final Node nodeXXLL = new Node(nodes[2].key, nodes[2].value, nodes[2].weight-1, nodes[2].left, nodes[2].right, dummy);
		final Node nodeXXLR = new Node(nodes[4].key, nodes[4].value, nodes[4].weight-1, nodes[4].left, nodes[4].right, dummy);
		final Node nodeXXL = new Node(nodes[1].key, nodes[1].value, 1, nodeXXLL, nodeXXLR, dummy);
		final int weight = nodes[1].weight;
		final Node nodeXX = new Node(nodes[3].key, nodes[3].value, weight, nodeXXL, nodes[3].right, dummy);
		return new Operation(nodes, ops, nodeXX);
	}

	private Operation createW2Op(final Node[] nodes, final Operation[] ops) {
		final Node nodeXXLL = new Node(nodes[2].key, nodes[2].value, nodes[2].weight-1, nodes[2].left, nodes[2].right, dummy);
		final Node nodeXXLR = new Node(nodes[4].key, nodes[4].value, 0, nodes[4].left, nodes[4].right, dummy);
		final Node nodeXXL = new Node(nodes[1].key, nodes[1].value, 1, nodeXXLL, nodeXXLR, dummy);
		final int weight = nodes[1].weight;
		final Node nodeXX = new Node(nodes[3].key, nodes[3].value, weight, nodeXXL, nodes[3].right, dummy);
		return new Operation(nodes, ops, nodeXX);
	}

	private Operation createW3Op(final Node[] nodes, final Operation[] ops) {
		final Node nodeXXLLL = new Node(nodes[2].key, nodes[2].value, nodes[2].weight-1, nodes[2].left, nodes[2].right, dummy);
		final Node nodeXXLL = new Node(nodes[1].key, nodes[1].value, 1, nodeXXLLL, nodes[5].left, dummy);
		final Node nodeXXLR = new Node(nodes[4].key, nodes[4].value, 1, nodes[5].right, nodes[4].right, dummy);
		final Node nodeXXL = new Node(nodes[5].key, nodes[5].value, 0, nodeXXLL, nodeXXLR, dummy);
		final int weight = nodes[1].weight;
		final Node nodeXX = new Node(nodes[3].key, nodes[3].value, weight, nodeXXL, nodes[3].right, dummy);
		return new Operation(nodes, ops, nodeXX);
	}

	private Operation createW4Op(final Node[] nodes, final Operation[] ops) {
		final Node nodeXXLL = new Node(nodes[2].key, nodes[2].value, nodes[2].weight-1, nodes[2].left, nodes[2].right, dummy);
		final Node nodeXXL = new Node(nodes[1].key, nodes[1].value, 1, nodeXXLL, nodes[4].left, dummy);
		final Node nodeXXRL = new Node(nodes[5].key, nodes[5].value, 1, nodes[5].left, nodes[5].right, dummy);
		final Node nodeXXR = new Node(nodes[3].key, nodes[3].value, 0, nodeXXRL, nodes[3].right, dummy);
		final int weight = nodes[1].weight;
		final Node nodeXX = new Node(nodes[4].key, nodes[4].value, weight, nodeXXL, nodeXXR, dummy);
		return new Operation(nodes, ops, nodeXX);
	}

	private Operation createW5Op(final Node[] nodes, final Operation[] ops) {
		final Node nodeXXLL = new Node(nodes[2].key, nodes[2].value, nodes[2].weight-1, nodes[2].left, nodes[2].right, dummy);
		final Node nodeXXL = new Node(nodes[1].key, nodes[1].value, 1, nodeXXLL, nodes[3].left, dummy);
		final Node nodeXXR = new Node(nodes[4].key, nodes[4].value, 1, nodes[4].left, nodes[4].right, dummy);
		final int weight = nodes[1].weight;
		final Node nodeXX = new Node(nodes[3].key, nodes[3].value, weight, nodeXXL, nodeXXR, dummy);
		return new Operation(nodes, ops, nodeXX);
	}

	private Operation createW6Op(final Node[] nodes, final Operation[] ops) {
		final Node nodeXXLL = new Node(nodes[2].key, nodes[2].value, nodes[2].weight-1, nodes[2].left, nodes[2].right, dummy);
		final Node nodeXXL = new Node(nodes[1].key, nodes[1].value, 1, nodeXXLL, nodes[4].left, dummy);
		final Node nodeXXR = new Node(nodes[3].key, nodes[3].value, 1, nodes[4].right, nodes[3].right, dummy);
		final int weight = nodes[1].weight;
		final Node nodeXX = new Node(nodes[4].key, nodes[4].value, weight, nodeXXL, nodeXXR, dummy);
		return new Operation(nodes, ops, nodeXX);
	}

	private Operation createW7Op(final Node[] nodes, final Operation[] ops) {
		final Node nodeXXL = new Node(nodes[2].key, nodes[2].value, nodes[2].weight-1, nodes[2].left, nodes[2].right, dummy);
		final Node nodeXXR = new Node(nodes[3].key, nodes[3].value, nodes[3].weight-1, nodes[3].left, nodes[3].right, dummy);
		final int weight = (isSentinel(nodes[1]) ? 1 : nodes[1].weight+1); // root of old subtree is a sentinel
		final Node nodeXX = new Node(nodes[1].key, nodes[1].value, weight, nodeXXL, nodeXXR, dummy);
		return new Operation(nodes, ops, nodeXX);
	}

	private Operation createRb1SymOp(final Node[] nodes, final Operation[] ops) {
		final Node nodeXL = new Node(nodes[1].key, nodes[1].value, 0, nodes[1].left, nodes[2].left, dummy);
		final int weight = nodes[1].weight;
		final Node nodeX = new Node(nodes[2].key, nodes[2].value, weight, nodeXL, nodes[2].right, dummy);
		return new Operation(nodes, ops, nodeX);
	}

	private Operation createRb2SymOp(final Node[] nodes, final Operation[] ops) {
		final Node nodeXL = new Node(nodes[1].key, nodes[1].value, 0, nodes[1].left, nodes[3].left, dummy);
		final Node nodeXR = new Node(nodes[2].key, nodes[2].value, 0, nodes[3].right, nodes[2].right, dummy);
		final int weight = nodes[1].weight;
		final Node nodeX = new Node(nodes[3].key, nodes[3].value, weight, nodeXL, nodeXR, dummy);
		return new Operation(nodes, ops, nodeX);
	}

	private Operation createPushSymOp(final Node[] nodes, final Operation[] ops) {
		final Node nodeXXL = new Node(nodes[2].key, nodes[2].value, 0, nodes[2].left, nodes[2].right, dummy);
		final Node nodeXXR = new Node(nodes[3].key, nodes[3].value, nodes[3].weight-1, nodes[3].left, nodes[3].right, dummy);
		final int weight = (isSentinel(nodes[1]) ? 1 : nodes[1].weight+1); // root of old subtree is a sentinel
		final Node nodeXX = new Node(nodes[1].key, nodes[1].value, weight, nodeXXL, nodeXXR, dummy);
		return new Operation(nodes, ops, nodeXX);
	}

	private Operation createW1SymOp(final Node[] nodes, final Operation[] ops) {
		final Node nodeXXRL = new Node(nodes[4].key, nodes[4].value, nodes[4].weight-1, nodes[4].left, nodes[4].right, dummy);
		final Node nodeXXRR = new Node(nodes[3].key, nodes[3].value, nodes[3].weight-1, nodes[3].left, nodes[3].right, dummy);
		final Node nodeXXR = new Node(nodes[1].key, nodes[1].value, 1, nodeXXRL, nodeXXRR, dummy);
		final int weight = nodes[1].weight;
		final Node nodeXX = new Node(nodes[2].key, nodes[2].value, weight, nodes[2].left, nodeXXR, dummy);
		return new Operation(nodes, ops, nodeXX);
	}

	private Operation createW2SymOp(final Node[] nodes, final Operation[] ops) {
		final Node nodeXXRL = new Node(nodes[4].key, nodes[4].value, 0, nodes[4].left, nodes[4].right, dummy);
		final Node nodeXXRR = new Node(nodes[3].key, nodes[3].value, nodes[3].weight-1, nodes[3].left, nodes[3].right, dummy);
		final Node nodeXXR = new Node(nodes[1].key, nodes[1].value, 1, nodeXXRL, nodeXXRR, dummy);
		final int weight = nodes[1].weight;
		final Node nodeXX = new Node(nodes[2].key, nodes[2].value, weight, nodes[2].left, nodeXXR, dummy);
		return new Operation(nodes, ops, nodeXX);
	}

	private Operation createW3SymOp(final Node[] nodes, final Operation[] ops) {
		final Node nodeXXRL = new Node(nodes[4].key, nodes[4].value, 1, nodes[4].left, nodes[5].left, dummy);
		final Node nodeXXRRR = new Node(nodes[3].key, nodes[3].value, nodes[3].weight-1, nodes[3].left, nodes[3].right, dummy);
		final Node nodeXXRR = new Node(nodes[1].key, nodes[1].value, 1, nodes[5].right, nodeXXRRR, dummy);
		final Node nodeXXR = new Node(nodes[5].key, nodes[5].value, 0, nodeXXRL, nodeXXRR, dummy);
		final int weight = nodes[1].weight;
		final Node nodeXX = new Node(nodes[2].key, nodes[2].value, weight, nodes[2].left, nodeXXR, dummy);
		return new Operation(nodes, ops, nodeXX);
	}

	private Operation createW4SymOp(final Node[] nodes, final Operation[] ops) {
		final Node nodeXXLR = new Node(nodes[5].key, nodes[5].value, 1, nodes[5].left, nodes[5].right, dummy);
		final Node nodeXXL = new Node(nodes[2].key, nodes[2].value, 0, nodes[2].left, nodeXXLR, dummy);
		final Node nodeXXRR = new Node(nodes[3].key, nodes[3].value, nodes[3].weight-1, nodes[3].left, nodes[3].right, dummy);
		final Node nodeXXR = new Node(nodes[1].key, nodes[1].value, 1, nodes[4].right, nodeXXRR, dummy);
		final int weight = nodes[1].weight;
		final Node nodeXX = new Node(nodes[4].key, nodes[4].value, weight, nodeXXL, nodeXXR, dummy);
		return new Operation(nodes, ops, nodeXX);
	}

	private Operation createW5SymOp(final Node[] nodes, final Operation[] ops) {
		final Node nodeXXL = new Node(nodes[4].key, nodes[4].value, 1, nodes[4].left, nodes[4].right, dummy);
		final Node nodeXXRR = new Node(nodes[3].key, nodes[3].value, nodes[3].weight-1, nodes[3].left, nodes[3].right, dummy);
		final Node nodeXXR = new Node(nodes[1].key, nodes[1].value, 1, nodes[2].right, nodeXXRR, dummy);
		final int weight = nodes[1].weight;
		final Node nodeXX = new Node(nodes[2].key, nodes[2].value, weight, nodeXXL, nodeXXR, dummy);
		return new Operation(nodes, ops, nodeXX);
	}

	private Operation createW6SymOp(final Node[] nodes, final Operation[] ops) {
		final Node nodeXXL = new Node(nodes[2].key, nodes[2].value, 1, nodes[2].left, nodes[4].left, dummy);
		final Node nodeXXRR = new Node(nodes[3].key, nodes[3].value, nodes[3].weight-1, nodes[3].left, nodes[3].right, dummy);
		final Node nodeXXR = new Node(nodes[1].key, nodes[1].value, 1, nodes[4].right, nodeXXRR, dummy);
		final int weight = nodes[1].weight;
		final Node nodeXX = new Node(nodes[4].key, nodes[4].value, weight, nodeXXL, nodeXXR, dummy);
		return new Operation(nodes, ops, nodeXX);
	}

	private Operation createW7SymOp(final Node[] nodes, final Operation[] ops) {
		final Node nodeXXL = new Node(nodes[2].key, nodes[2].value, nodes[2].weight-1, nodes[2].left, nodes[2].right, dummy);
		final Node nodeXXR = new Node(nodes[3].key, nodes[3].value, nodes[3].weight-1, nodes[3].left, nodes[3].right, dummy);
		final int weight = (isSentinel(nodes[1]) ? 1 : nodes[1].weight+1); // root of old subtree is a sentinel
		final Node nodeXX = new Node(nodes[1].key, nodes[1].value, weight, nodeXXL, nodeXXR, dummy);
		return new Operation(nodes, ops, nodeXX);
	}

}